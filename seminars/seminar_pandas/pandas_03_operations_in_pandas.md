---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Работа с данными в Pandas


Одной из важнейших особенностей NumPy является возможность выполнять быстрые поэлементные операции, как с использованием базовой арифметики (сложение, вычитание, умножение и т.д.), так и с использованием более сложных операций (тригонометрические функции, показательные и логарифмические функции и т.д.).
Pandas унаследовал большую часть этой функциональности от NumPy, и универсальные функции, рассмотренные ранее <!--в [CВычисления на массивах NumPy: универсальные функции](numpy_03_computation_on_arrays_ufuncs.md) -->, играют в этом ключевую роль.

Однако Pandas включает в себя несколько полезных особенностей: для унарных операций, таких как отрицание и тригонометрические функции, эти универсальные функции будут *сохранять индексы и метки столбцов* в выходных данных, а для бинарных операций, таких как сложение и умножение, Pandas будет автоматически *выравнивать индексы* при передаче объектов в универсальную функцию.
Это значит, что сохранение контекста данных и объединение данных из различных источников &mdash; две задачи, потенциально чреватые ошибками
при работе с исходными массивами библиотеки NumPy, &mdash; становятся надежно защищенными от ошибок благодаря библиотеке Pandas.
Кроме того, в библиотеке заданы операции между одномерными структурами объектов `Series` и двумерными структурами объектов `DataFrame`.


## Универсальные функции: Сохранение индекса

Поскольку Pandas основан на NumPy, любая универсальная функция NumPy будет работать с объектами Pandas `Series` и `DataFrame`.
Начнем с определения простого `Series` и `DataFrame`, на которых это продемонстрируем:

```python
import numpy as np
import pandas as pd
```

```python jupyter={"outputs_hidden": false}
rng = np.random.RandomState(42)
ser = pd.Series(rng.randint(0, 10, 4))
ser
```

```python jupyter={"outputs_hidden": false}
df = pd.DataFrame(rng.randint(0, 10, (3, 4)),
                  columns=['A', 'B', 'C', 'D'])
df
```

Если применить универсальную функцию NumPy к любому из этих объектов, результатом будет еще один объект Pandas, индексация при этом сохраняется:

```python jupyter={"outputs_hidden": false}
np.exp(ser)
```

Или, для немного более сложного расчета:

```python jupyter={"outputs_hidden": false}
np.sin(df * np.pi / 4)
```

Любую из универсальных функций <!--, обсуждаемых в [Вычисления на массивах NumPy: универсальные функции](numpy_03_computation_on_arrays_ufuncs.md), --> можно использовать аналогичным образом.


## Универсальные функции: Выравнивание индексов

Для бинарных операций над двумя объектами `Series` или `DataFrame` Pandas выравнивает индексы в процессе выполнения операции.
Это очень удобно при работе с неполными данными.


### Выравнивание индекса в серии `Series`

В качестве примера предположим, что необходимо объединить два разных источника содержащих только три города с *наибольшей площадью* и три города с наибольшим *населением*:

```python jupyter={"outputs_hidden": false}
area = pd.Series({'Москва': 2561.5,
                  'Санкт-Петербург': 1439.0,
                  'Екатеринбург': 1110.7,})
population = pd.Series({'Москва': 13149803,
                        'Санкт-Петербург': 5597763,
                        'Новосибирск': 1633851,})
```

<!-- #region slideshow={"slide_type": "fragment"} -->
Посмотрим, что произойдет, если попытаться вычислить плотность населения:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
population / area
```

Результирующий массив содержит *объединение* индексов двух входных массивов, которые можно определить с помощью стандартной арифметики множеств Python для этих индексов:

```python jupyter={"outputs_hidden": false}
set(area.index) | set(population.index)
```

Любой элемент, для которого не существует записи, помечается как `NaN` (Not-a-Number), (Не число), &mdash; именно так Pandas отмечает отсутствующие данные (более подробное обсуждение отсутствующих данных см. в [Обработка отсутствующих данных](pandas_04_missing_values.md)).
Аналогичным образом реализовано сопоставление индексов для всех встроенных арифметических выражений языка Python: все отсутствующие значения заполняются по умолчанию значением `NaN`:

```python jupyter={"outputs_hidden": false}
A = pd.Series([2, 4, 6], index=[0, 1, 2])
B = pd.Series([1, 3, 5], index=[1, 2, 3])
A + B
```

Если использование значений `NaN` нежелательно, значение заполнения можно изменить, используя соответствующие методы объекта вместо операторов.
Например, вызов `A.add(B)` эквивалентен вызову `A + B`, но допускает необязательное явное указание значения заполнения для любых элементов в `A` или `B`, которые могут отсутствовать:

```python jupyter={"outputs_hidden": false}
A.add(B, fill_value=0)
```

### Выравнивание индексов в `DataFrame`

При выполнении операций над объектами `DataFrame` происходит аналогичное вы равнивание как для столбцов, так и для индексов::

```python jupyter={"outputs_hidden": false}
A = pd.DataFrame(rng.randint(0, 20, (2, 2)),
                 columns=['A', 'B'])
A
```

```python jupyter={"outputs_hidden": false}
B = pd.DataFrame(rng.randint(0, 10, (3, 3)),
                 columns=['A', 'C', 'B',],
                index=[2, 0, 1])
B
```

```python jupyter={"outputs_hidden": false}
A + B
```

Обратите внимание, что индексы выровнены правильно независимо от их порядка в двух объектах, а индексы в результате отсортированы.
Как и в случае с `Series`, можно использовать арифметический метод связанного объекта и передать любое желаемое значение `fill_value` для использования вместо отсутствующих записей.
В следующем примере заполним отсутствующие значения средним значением всех элементов объекта A (которое вычислим, выстроив сначала значения объекта A в один столбец с помощью функции stack):

```python jupyter={"outputs_hidden": false}
fill = A.stack().mean()
A.add(B, fill_value=fill)
```

В следующей таблице перечислены операторы Python и эквивалентные им методы объектов Pandas:

| Оператор Python | Метод(ы) Pandas |
|-----------------|-----------------|
| `+`  | `add()`                    | 
| `-`  | `sub()`, `subtract()`           |
| `*`  | `mul()`, `multiply()`           |
| `/`  | `truediv()`, `div()`, `divide()`|
| `//` | `floordiv()`                    |
| `%`  | `mod()`                         |
| `**` | `pow()`                         |



## Универсальные функции: выполнение операции между объектами `DataFrame` и `Series`

При выполнении операций между `DataFrame` и `Series` выравнивание столбцовиндексо сохраняется аналогичным образом.
Операции между `DataFrame` и `Series` аналогичны операциям между двумерным и одномерным массивом NumPy.
Рассмотрим одну из часто встречающихся операций &mdash; вычисление разности двумерного массива и одной из его строк:

```python jupyter={"outputs_hidden": false}
A = rng.randint(10, size=(3, 4))
A
```

```python jupyter={"outputs_hidden": false}
A - A[0]
```

Согласно правилам трансляции NumPy <!--(см. [Операции над массивами: транслирование](numpy_05_computation_on_arrays_broadcasting.md))-->, вычитание между двумерным массивом и одной из его строк применяется построчно.

В Pandas соглашение по умолчанию аналогично действует построчно:

```python jupyter={"outputs_hidden": false}
data = pd.DataFrame(A, columns=list('ABCD'))
```

```python jupyter={"outputs_hidden": false}
data - data.iloc[0]
```

Если вместо этого необходимо работать со столбцами, можно использовать методы объектов, упомянутые ранее, указав ключевое слово `axis`:

```python jupyter={"outputs_hidden": false}
data.subtract(data['C'], axis=0)
```

Обратите внимание, что эти операции `DataFrame`/`Series`, как и операции, рассмотренные выше, автоматически выравнивают индексы между двумя элементами:

```python jupyter={"outputs_hidden": false}
halfrow = data.iloc[0, ::2]
halfrow
```

```python jupyter={"outputs_hidden": false}
data - halfrow
```

Такое сохранение и выравнивание индексов и столбцов означает, что операции с данными в Pandas всегда будут поддерживать контекст данных, что предотвращает возникновение нелепых ошибок, которые могут возникнуть при работе с неоднородными и/или невыровненными данными в необработанных массивах NumPy.
