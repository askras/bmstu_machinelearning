---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Индексация и выборка данных


Рассмотрим способы доступа к значениям и их изменения в объектах Pandas `Series` и `DataFrame`.
Методы доступа к элементам Pandas очень сильно похожи на соответствующие методы NumPy, хотя есть несколько особенностей, о которых следует знать.

Начнем с простого случая одномерного объекта `Series`, а затем перейдем к более сложному двумерному объекту `DataFrame`.

Объект `Series` во многом ведет себя подобно одномерному массиву библиотеки
NumPy и стандартному словарю языка Python.



###  `Series` как словарь

Как и словарь, объект `Series` обеспечивает отображение коллекции ключей в коллекцию значений:

```python jupyter={"outputs_hidden": false}
import pandas as pd
data = pd.Series([0.25, 0.5, 0.75, 1.0],
                 index=['a', 'b', 'c', 'd'])
data
```

```python jupyter={"outputs_hidden": false}
data['b']
```

Для просмотра ключей/индексов и значений выражения можно также использовать методы языка Python, аналогичные таковым для словарей:

```python jupyter={"outputs_hidden": false}
'a' in data
```

```python jupyter={"outputs_hidden": false}
data.keys()
```

```python jupyter={"outputs_hidden": false}
list(data.items())
```

Объекты `Series` можно изменять с помощью синтаксиса, похожево на синтаксис для словарей. 
Аналогично расширению словаря путем присваивания значения для нового ключа, можно расширить объект Series, присвоив значение для нового значения индекса:

```python jupyter={"outputs_hidden": false}
data['e'] = 1.25
data
```

Такая простота изменения объектов является очень удобной: Pandas сам принимает решения о структуре памяти и копировании данных, которые могут потребоваться. 
Пользователю, как правило, не нужно беспокоиться об этих проблемах.


## Выборка данных из объекта Series


### `Series` как одномерный массив


Объект `Series`, основываясь на интерфейсе, напоминающем словарь, предоставляет возможность выборки элементов с помощью тех же базовых механизмов, что
и для массивов NumPy, то есть срезов, булевых и индексации списками.
Приведем несколько примеров:

```python jupyter={"outputs_hidden": false}
# срез посредством явного индекса
data['a':'c']
```

```python jupyter={"outputs_hidden": false}
# срез посредством неявного целочисленного индекса
data[0:2]
```

```python jupyter={"outputs_hidden": false}
# маскировка
data[(data > 0.3) & (data < 0.8)]
```

```python jupyter={"outputs_hidden": false}
# списочная индексация
data[['a', 'e']]
```

Следует обратить внимание, что при выполнении среза с явным индексом (например, `data['a':'c']`), конечный индекс *включается* в срез, тогда как при выполнении среза с неявным индексом (например, `data[0:2]`), конечный индекс *исключается* из среза.

Подобные соглашения для срезов и индексации могут привести к путанице.
Например, при наличии у объекта `Series` явного целочисленного индекса операция индексации (data[1]) будет использовать явные индексы, а операция среза
(data[1:3] ) &mdash; неявный индекс в стиле языка Python.

```python jupyter={"outputs_hidden": false}
data = pd.Series(['a', 'b', 'c', ], index=[1, 3, 6])
data
```

```python jupyter={"outputs_hidden": false}
# явный индекс при индексации
data[3]
```

```python jupyter={"outputs_hidden": false}
# неявный индекс при выполнении среза
data[1:3]
```

### Индексаторы: loc, iloc

Чтобы избавиться от этой потенциальной путаницы в случае целочисленных индексов, Pandas предоставляет некоторые специальные атрибуты *indexer*, позволяющие явно указывать желаемый метод индексации индексации.
Отметим, что это не методы объекта, а атрибуты, которые предоставляют определенный интерфейс среза для данных в `Series`.


Атрибут `loc` позволяет выполнять индексацию и срезы, которые всегда используют на явный индекс:

```python jupyter={"outputs_hidden": false}
data.loc[1]
```

```python jupyter={"outputs_hidden": false}
data.loc[1:3]
```

Атрибут `loc` позволяет выполнять индексацию и срезы, которые всегда используют на явный индекс в стиле Python:

```python jupyter={"outputs_hidden": false}
data.iloc[1]
```

```python jupyter={"outputs_hidden": false}
data.iloc[1:3]
```

Явный синтаксис делает методы `loc` и `iloc` очень полезными для поддержания чистого и читаемого кода; особенно в случае целочисленных индексов.
Рекомендуется использовать их оба, чтобы сделать код более легким для чтения и понимания, а также предотвратить тонкие ошибки из-за смешанного соглашения об индексации/срезе.


## Выборка данных из объекта DataFrame

`DataFrame` с одной стороны можно рассматривать как двумерный или структурированный массив, а с другой &mdash; как словарь структур `Series` с общим индексом.
Эти аналогии полезно иметь в виду при изучении способов выборки данных данных из этого объекта.


### DataFrame как словарь

Вернемся к примеру с площадями и населением городов:

```python jupyter={"outputs_hidden": false}
area = pd.Series({'Москва': 2561.5,
                  'Санкт-Петербург': 1439.0,
                  'Новосибирск': 502.7,
                  'Екатеринбург': 1110.7,
                  'Казань': 638.4,
                  'Красноярск': 413.0,})
pop = pd.Series({'Москва': 13149803,
                 'Санкт-Петербург': 5597763,
                 'Новосибирск': 1633851,
                 'Екатеринбург': 1536183,
                 'Казань': 1318604,
                 'Красноярск': 1205473,})
data = pd.DataFrame({'area':area, 'pop':population})
data
```

Доступ к отдельным `Series`, составляющим столбцы `DataFrame`, можно получить с помощью индекса имени столбца в стиле словаря:

```python jupyter={"outputs_hidden": false}
data['area']
```

Если именами столбцов являются строки, можно использовать доступ в стиле атрибутов:

```python jupyter={"outputs_hidden": false}
data.area
```

При доступе к столбцу по имени атрибута фактически происходит обращение к тому же объекту, что и при словарном варианте доступа:

```python jupyter={"outputs_hidden": false}
data.area is data['area']
```

Это очень удобный вариант доступа, но следует помнить, что он работает не во всех случаях!
Например, если имена столбцов не являются строками или если имена столбцов конфликтуют с методами `DataFrame`, такой доступ в стиле атрибутов невозможен.
Например, `DataFrame` имеет метод `pop()`, поэтому `data.pop` будет указывать на него, а не на столбец `'pop'`:

```python jupyter={"outputs_hidden": false}
data.pop is data['pop']
```

```python
type(data.pop), type(data['pop'])
```

В частности, следует избегать соблазна попытаться изменятьзначения столбцов посредством атрибутов. 
Лучше использовать выражение `data['pop'] = z` вместо `data.pop = z`.


Как и в случае с объектами `Series`, обсуждавшимися ранее, синтаксис в стиле словаря также можно использовать для изменения объекта, в данном случае для добавления нового столбца:

```python jupyter={"outputs_hidden": false}
data['density'] = data['pop'] / data['area']
data
```

Приведенный пример демонстрирует простоту синтаксиса поэлементных операций над объектами Series, который рассмотрим в в [Работа с данными в Pandas](pandas_03_operations_in_pandas.md).


### DataFrame как двумерный массив

Как упоминалось ранее, `DataFrame` можно рассматривать как двумерный массив с расширенными возможностями.
Просмотреть массив, лежащий в основе `DataFrame` можно используя атрибут `values`:

```python jupyter={"outputs_hidden": false}
data.values
```

Исходя из этих соображений, над объектом `DataFrame`, можно выполнить множество привычных для массивов действий.
Например, транспонировать его:

```python jupyter={"outputs_hidden": false}
data.T
```

Однако когда дело доходит до индексации объектов `DataFrame`, становится ясно, что индексация столбцов в стиле словаря исключает возможность простого обращения с ними как с массивом NumPy.
В частности, передача одного индекса в массив обеспечивает доступ к строке:

```python jupyter={"outputs_hidden": false}
data.values[0]
```

а передача одного &laquo;индекса&raquo; в `DataFrame` вернет столбец:

```python jupyter={"outputs_hidden": false}
data['area']
```

<!-- #region jupyter={"outputs_hidden": true} -->
Таким образом, для индексации в стиле массива необходимо другое соглашение.
Здесь Pandas снова предлагает использовать индексаторы `loc` и `iloc`.
Используя индексатор `iloc`, можно индексировать базовый массив так, как будто это простой массив NumPy (используя неявный индекс в стиле Python), но индекс `DataFrame` и метки столбцов сохраняются в результате:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
data.iloc[:3, :2]
```

Аналогично, используя индексатор `loc`, можно индексировать данные в стиле массива, но используя явные имена индекса и столбцов:

```python jupyter={"outputs_hidden": false}
data.loc[:'Екатеринбург', :'pop']
```

В этих индексаторах можно использовать любой из известных шаблонов доступа к данным в стиле NumPy.
Например, в индексаторе `loc` можно объединить булевы маски и списочную индексацию следующим образом:

```python jupyter={"outputs_hidden": false}
data.loc[data.density > 2500, ['pop', 'density']]
```

Любой из этих вариантов синтаксиса можно применять для добавления или изменения значений:

```python jupyter={"outputs_hidden": false}
data.iloc[0, 1] = 15000000
data
```

### Дополнительные соглашения об индексации

Существует несколько дополнительных правил индексации, которые могут показаться противоречащими предыдущему обсуждению, но, тем не менее, могут быть очень полезны на практике.
Во-первых, *индексация* относится к столбцам, а *срезы* &mdash; к строкам:

```python jupyter={"outputs_hidden": false}
data['Новосибирск':'Казань']
```

Срезы также могут ссылаться на строки по номеру, а не по индексу:

```python jupyter={"outputs_hidden": false}
data[1:3]
```

Непосредственные операции маскирования также интерпретируются построчно, а не по столбцам:

```python jupyter={"outputs_hidden": false}
data[data['density'] > 2500]
```

Эти два соглашения синтаксически похожи на соглашения в массиве NumPy, и хотя они не совсем соответствуют соглашениям Pandas, они, тем не менее, весьма полезны на практике.
