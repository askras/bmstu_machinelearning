---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Обработка отсутствующих данных


<!-- пустые - пропущенные --> 

Реальные данные редко бывают чистыми и однородными.
В частности, во многих интересных наборах данных отсутствует часть данных.
Еще больше усложняет ситуацию тот факт, что в разных источниках данных отсутствующие данные могут быть помечены по разному.

В этом разделе обсудим некоторые общие соображения относительно отсутствующих данных, обсудим, как Pandas выбирает способ их представления, и продемонстрируем некоторые встроенные инструменты Pandas для обработки отсутствующих данных.
Здесь и далее отсутствующие данные будут помечены значениями *null*, *NaN* или *NA*.


## Компромиссы в соглашениях об отсутствующих данных

Разработано несколько схем для указания наличия отсутствующих данных в таблице или DataFrame.
Они основываются на одной из двух стратегий: использование *маски*, которая глобально указывает на отсутствующие значения, или выбор *сигнального значения*, которое указывает на отсутствующую запись.

Маска может представлять собой совершенно отдельный логический массив или может включать добавление одного бита в представлении данных для локального указания нулевого статуса значения.

В подходе с использованием сигнальных значений, такое значение может быть каким-либо соглашением, специфичным для данных, например, указанием отсутствующего целочисленного значения с помощью -9999 или какой-либо редкой битовой комбинации. Или это может быть более глобальное соглашение, например, указанием отсутствующего значения с плавающей точкой с помощью NaN (не число), специального значения, которое является частью спецификации IEEE для чисел с плавающей точкой.

Ни один из этих подходов не обходится без компромиссов: использование отдельного массива масок требует выделения дополнительного булевого массива, что добавляет накладные расходы как при хранении, так и при вычислениях. Сигнальное значение сокращает диапазон допустимых значений, которые могут быть представлены, и может потребовать дополнительной (часто неоптимизированной) логики в арифметических операциях на CPU или GPU.
Общепринятые специальные значения, такие как NaN, доступны не для всех типов данных.

Как и в большинстве случаев, когда не существует универсально оптимального варианта, разные языки и системы используют разные соглашения.
Например, язык R использует зарезервированные битовые шаблоны в каждом типе данных в качестве контрольных значений, указывающих на отсутствующие данные, в то время как система SciDB использует дополнительный байт, прикрепленный к каждой ячейке.


## Отсутствующие данные в Pandas

Способ обработки пропущенных значений библиотекой Pandas ограничен ее зависимостью от пакета NumPy, в котором нет встроенного понятия NA-значений для типов данных, отличных от чисел с плавающей точкой.

Pandas мог бы последовать примеру R и указать битовые шаблоны для каждого отдельного типа данных, чтобы обозначить нулевое значение, но такой подход оказался довольно громоздким.
В то время как R содержит четыре основных типа данных, NumPy поддерживает *гораздо* больше: например, в то время как R имеет один целочисленный тип, NumPy поддерживает *четырнадцать* основных целочисленных типов, если учесть доступную точность, знаковость и порядок байтов кодировки.
Резервирование определенного битового шаблона во всех доступных типах NumPy приведет к громоздкому количеству накладных расходов в специальных случаях различных операций для различных типов, вероятно, даже требуя новой ветки пакета NumPy. 
Кроме того, для меньших типов данных (таких как 8-битные целые числа) жертвование битом для использования в качестве маски значительно сократит диапазон значений, которые он может представлять.

NumPy поддерживает маскированные массивы, то есть массивы, к которым прикреплен отдельный массив булевой маски для маркировки данных как &laquo;хороших&raquo; или &laquo;плохих&raquo;.
Pandas мог бы создать нечто подобное, но из-за накладных расходов на хранение, вычисления и поддержку кода это решение становится непривлекательным.

Учитывая эти ограничения, разработчики Pandas решили использовать сигнальные метки для отсутствующих данных, а также использовать два уже существующих нулевых значения Python: специальное значение с плавающей точкой `NaN` и объект Python `None`.
Этот выбор имеет некоторые побочные эффекты, но на практике в большинстве случаев оказывается хорошим компромиссом.


### `None`: пропущенные данные в языке Python

Первое контрольное значение, используемое Pandas, &mdash; это `None`, одноэлементный объект Python, который часто используется для отсутствующих данных в коде Python.
Поскольку это объект Python, `None` нельзя использовать в любом произвольном массиве NumPy/Pandas, а только в массивах с типом данных `object` (т. е. массивах объектов Python):

```python
import numpy as np
import pandas as pd
```

```python jupyter={"outputs_hidden": false}
vals1 = np.array([1, None, 3, 4])
vals1
```

`dtype=object` означает, что наилучшим общим представлением типа, которое NumPy может вывести для содержимого массива, является то, что это объекты Python.
Хотя такая разновидность массивов полезна для определенных целей, все операции над ними будут выполняться на уровне языка Python, с накладными расходами, значительно превышающими расходы на выполнение быстрых операций над массивами с нативными типами данных:

```python jupyter={"outputs_hidden": false}
for dtype in ['object', 'int']:
    print('dtype =', dtype)
    %timeit np.arange(1E6, dtype=dtype).sum()
    print()
```

Использование объектов языка Python в массивах означает также, что при выполнении функций агрегирования по массиву со значениями `None`, например `sum()` или `min()`, будет возвращена ошибка:

```python jupyter={"outputs_hidden": false}
%%capture

vals1.sum()
```

Эта ошибка отражает тот факт, что операция между целочисленным значением и значением `None` не определена.


### `NaN`: Пропущенные числовые данные

Еще одно представление отсутствующих данных, `NaN`, представляет собой специальное значение с плавающей точкой, распознаваемое всеми системами, использующими стандарное IEEE-представление чисел с плавающей точкой:

```python jupyter={"outputs_hidden": false}
vals2 = np.array([1, np.nan, 3, 4]) 
vals2.dtype
```

Обратите внимание, что NumPy выбрал для этого массива собственный тип с плавающей точкой.
Это означает, что в отличие от массива объектов, который использовался ранее, этот массив поддерживает быстрые операции, передаваемые на выполнение скомпилированному коду.
Следует знать, что `NaN` немного похож на &laquo;вирус&raquo; данных &mdash; он &laquo;заражает&raquo; любой другой объект, к которому прикасается.
Независимо от операции,  результат арифметического действия с `NaN` будет равен `NaN`:

```python jupyter={"outputs_hidden": false}
1 + np.nan
```

```python jupyter={"outputs_hidden": false}
0 *  np.nan
```

Обратите внимание, что при наличии в данных значения `NaN`, операция агрегирования значений не вызовет ощибку, но ее результатом всегда будет `NaN`:

```python jupyter={"outputs_hidden": false}
vals2.sum(), vals2.min(), vals2.max()
```

NumPy предоставляет некоторые специальные функции агрегирования, которые будут игнорировать отсутствующие значения:

```python jupyter={"outputs_hidden": false}
np.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2)
```

Следует помнить, что `NaN` &mdash; это именно значение с плавающей точкой. 
Эквивалентного значения для целых чисел, строк или других типов не существует.


### NaN и None в Pandas

Как у `NaN`, так и у `None` есть свое назначение, и библиотека Pandas делает их практически взаимозаменяемыми путем преобразования одного в другое в определенных случаях:

```python jupyter={"outputs_hidden": false}
pd.Series([1, np.nan, 2, None])
```

Для типов, у которых нет доступного сигнального значения, Pandas автоматически выполняет приведение типов при наличии отсутствующих значений.
Например, если добавить значение  `np.nan` в целочисленном массиве, он будет автоматически преобразовано в тип с плавающей точкой для соответствия типу отсутствующего значения:

```python jupyter={"outputs_hidden": false}
x = pd.Series(range(2), dtype=int)
x
```

```python jupyter={"outputs_hidden": false}
x[0] = None
x
```

Обратите внимание, что помимо приведения целочисленного массива к типу с плавающей точкой, Pandas автоматически преобразует `None` в значение `NaN`.
Существует план по внесению в будущем нативного целочисленного NA в библиотеку Pandas, но на данный момент оно еще не включено.

Хотя подобный подход со значениями-индикаторами/приведением типов библиотеки Pandas может показаться немного нелогичным по сравнению с более унифицированным подходом к значениям NA в предметно-ориентированных языках, таких как R, на практике работает довольно хорошо и, лишь изредка вызывает проблемы.

В следующей таблице перечислены соглашения о приведении типов в Pandas при введении NA-значений:

|Класс типов   | Преобразование при NA-cохранении | Значение-индикатор NA |
|--------------|-----------------------------|-----------------------|
| `числа с плавающей точкой` | Без изменений | `np.nan` |
| Объект (`object`)          | Без изменений | `None` или `np.nan` |
| Целые числа                | `float64`     | `np.nan` |
| Логическое значение        | `object`      | `None` или `np.nan` |

Строковые данные в Pandas всегда хранятся с типом данных `object`.


## Операции с пропущенными значениями

Pandas рассматривает `None` и `NaN` как по сути взаимозаменяемые значения для указания отсутствующих или нулевых значений.
Существует несколько полезных методов  обнаружения, удаления и замены нулевых значений в структурах данных Pandas, призванных упростить работу с ними.

- `isnull()`: генерирует булеву маску для отсутсвующих значений;
- `notnull()`: ротивоположность `isnull()`;
- `dropna()`: возвращает отфильтрованную версию данных;
- `fillna()`: возвращает копию данных с заполненными или подставленными пропущенными значениями.

Завершим этот раздел кратким исследованием и демонстрацией этих методов.


### Обнаружение пропущенных значений
В структурах данных Pandas есть два полезных метода для обнаружения нулевых данных: `isnull()` и `notnull()`.
Любой из них вернет булеву маску по данным. Например:

```python
data = pd.Series([1, np.nan, 'hello', None])
```

```python jupyter={"outputs_hidden": false}
data.isnull()
```

```python
data.notnull()
```

Как и в случае с массивами NumPy, булевы маски можно использовать напрямую в качестве индекса `Series` или `DataFrame`:

```python jupyter={"outputs_hidden": false}
data[data.notnull()]
```

Для `DataFrame` методы `isnull()` и `notnull()` выдают схожие результаты 


### Удаление пропущенных значений

Существуют удобные методы `dropna()` (который удаляет NA-значения) и `fillna()` (который заполняет NA-значения). 
Для `Series`, результат прост:

```python jupyter={"outputs_hidden": false}
data.dropna()
```

Для `DataFrame` существует больше возможностей:

```python jupyter={"outputs_hidden": false}
data = pd.DataFrame([[1,      np.nan, 2],
                     [2,      3,      5],
                     [np.nan, 4,      6]])
data
```

Нельзя выбросить из `DataFrame` отдельные значения, только целые строки или столбцы. 
В зависимости от приложения может понадобиться тот или иной вариант, так что функция `dropna()` предоставляет для случая объектов `DataFrame` несколько параметров.

По умолчанию `dropna()` удалит все строки, в которых присутствует хотя бы одно пропущенное значение:

```python jupyter={"outputs_hidden": false}
data.dropna()
```

В качестве альтернативы можно удалить пропущенные значения вдоль другой оси.
`axis=1` или `'axis=columns'` удаляет все столбцы, содержащие пропущенные значения:

```python jupyter={"outputs_hidden": false}
data.dropna(axis=1)
```

Однако при этом отбрасываются и некоторые полезные данные.
Возможно, лучще отбрасывать лишь те строки или столбцы со *всеми* (или большинством) пропущенных значений.
Такое поведение можно задать с помощью параметров `how` или `thresh`, которые позволяют точно контролировать количество допустимых пропущенных значений.

Значение по умолчанию &mdash; `how='any'`, то есть любая строка или столбец (в зависимости от ключевого слова `axis`), содержащие пропущенное значение, будут удалены.
Указание `how='all'`, приведет к удалению только тех строк/столбцов, в которые *все* значения пропущены (пустые):

```python jupyter={"outputs_hidden": false}
data[3] = np.nan
data
```

```python jupyter={"outputs_hidden": false}
data.dropna(axis='columns', how='all')
```

Для более точного управления параметр `thresh` позволяет указать минимальное количество ненулевых значений для строки/столбца, которые необходимо сохранить:

```python jupyter={"outputs_hidden": false}
data.dropna(axis='rows', thresh=3)
```

Здесь первая и последняя строки были удалены, поскольку они содержат только два не пустых значения.


### Заполнение пропущенных значений

Иногда вместо того, чтобы отбрасывать строки (столбцы), содержащие пропущенные значения, лучше заменить их допустимым значением.
Это значение может быть фиксированным, например нулем, или интерполированным или восстановленным на основе &laquo;хороших&raquo; данных значением. 
Это можно сделать путем замены в исходных данных, используя результат метода `isnull()` в качестве маски. 
Но это настолько распространенная операция, что библиотека Pandas предоставляет метод `fillna()`, возвращающий копию массива с замененными пустыми значениями.

Рассмотрим следующий объект `Series`:

```python jupyter={"outputs_hidden": false}
data = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))
data
```

Можно заполнить пропущенные элементы одним фиксированным значением, например, нулями:

```python jupyter={"outputs_hidden": false}
data.fillna(0)
```

Можно задать параметр заполнения по направлению &laquo;вперед&raquo;, копируя предыдущее значение в следующую ячейку:

```python jupyter={"outputs_hidden": false}
# заполнение по направлению "вперед"
data.ffill()
```

Или можно задать параметр заполнения по направлению &laquo;назад&raquo;, копируя следующее значение в предыдущую ячейку:

```python jupyter={"outputs_hidden": false}
# заполнение по направлению "назад"
data.bfill()
```

<!-- #region jupyter={"outputs_hidden": true} -->
Для объектов `DataFrame` опции аналогичны, но в дополнение можно задать ось, по которой будет выполняться заполнение:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
data = pd.DataFrame([[np.nan, 1,      np.nan,],
                     [np.nan,      3,      np.nan,],
                     [np.nan, 4,      6]])
data
```

```python jupyter={"outputs_hidden": false}
data.ffill(axis=1)
```

Обратите внимание: если предыдущее значение недоступно во время прямого заполнения, сохраняется значение NA.
