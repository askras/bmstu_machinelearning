---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Сводные таблицы


`GroupBy` позволяет исследовать взаимосвязи внутри набора данных.
*Сводная таблица* (pivot table) &mdash; это похожая операция, которая часто встречается в электронных таблицах и других программах, работающих с табличными данными.
Сводная таблица принимает в качестве входных данных простые данные по столбцам и группирует записи в двумерную таблицу, которая обеспечивает многомерное обобщение данных.
Чтобы сходство между сводными таблицами и `GroupBy` не вызывала путаницу, полезно думать о сводных таблицах как о по сути *многомерной* версии агрегации `GroupBy`.
То есть в процессе разделения-применения-объединяения, и разделение, и объединение происходят не по одномерному индексу, а по двумерной сетке.


## Данные для примеров работы со сводными таблицами

Для примеров в этом разделе мы будем использовать базу данных пассажиров *Титаника*, предоставляемую пакетом Seaborn:

```python jupyter={"outputs_hidden": false}
import numpy as np
import pandas as pd
import seaborn as sns
titanic = sns.load_dataset('titanic')
```

```python jupyter={"outputs_hidden": false}
titanic.head()
```

Здесь содержится большой объем информации о каждом пассажире того злополучного рейса, включая пол, возраст, класс, оплаченную стоимость проезда и многое другое.


## Создание сводных таблицы вручную

Приступая к анализу данных, можно бы начать с группировки по полу, статусу выживания или некоторой комбинации этих признаков.
Для этого можно было бы применить операцию GroupBy &mdash;, например, давайте рассмотрим коэффициент выживаемости по полу:

```python jupyter={"outputs_hidden": false}
titanic.groupby('sex')[['survived']].mean()
```

Это сразу дает некоторое представление: в целом, выжили три из четырех женщин на борту, в то время как выжил только один из пяти мужчин!

Однако, можно, копнуть еще глубже и рассмотреть еще распределение выживших по полу и, скажем, классу.
Используя словарь `GroupBy`, можно было бы действовать следующим образом:
*группировать* по классу и полу, *выбрать* выживаемость, *применить* агрегирующию функцию для вычисления среднего значения, *объединить* полученные группы, а затем *распаковать* иерархический индекс, чтобы выявить скрытую многомерность. 
Итак,:

```python jupyter={"outputs_hidden": false}
titanic.groupby(['sex', 'class'], observed=True)['survived'].aggregate('mean').unstack()
```

Это дает лучшее представление о том, как пол и класс влияют на выживание, но код становится относительно сложным.
Хотя каждый шаг этого конвейера довольно прост, полученную в итоге длинную строку кода не так-то просто читать и использовать.
Двумерный `GroupBy` настолько распространен, что в Pandas включена удобная процедура `pivot_table`, позволяющий описывать более кратко данную разновидность многомерного агрегирования.


## Синтаксис сводных таблиц

Вот эквивалент предыдущей операции с использованием метода `pivot_table` из `DataFrame`:

```python jupyter={"outputs_hidden": false}
titanic.pivot_table('survived', index='sex', columns='class', observed=True)
```

Это гораздо более удобный для чтения вариант.
Как и следовало ожидать от трансатлантического круиза начала XX века, шансы на выживание были выше у женщин и представителей высших классов.
Женщины первого класса выживали почти наверняка (привет, Роуз!), тогда как среди мужчин третьего класса выживал лишь один из десяти (извини, Джек!).


### Многоуровневые сводные таблицы

Как и в `GroupBy`, группировку в сводных таблицах можно задавать на нескольких уровнях, при этом доступно множество параметров для тонкой настройки результата.
Например, интересно было бы взглянуть на возраст в качестве третьего измерения
Разобьем данные на интервалы по возрасту с помощью функции `pd.cut`:

```python jupyter={"outputs_hidden": false}
age = pd.cut(titanic['age'], [0, 18, 80])
titanic.pivot_table('survived', ['sex', age], 'class',  observed=True)
```

Эту же стратегию можем применить и при работе со столбцами.
Давайте добавим информацию об оплаченной стоимости проезда, используя `pd.qcut` для автоматического вычисления квантилей:

```python jupyter={"outputs_hidden": false}
fare = pd.qcut(titanic['fare'], 2)
titanic.pivot_table('survived', ['sex', age], [fare, 'class'], observed=True)
```

Результатом является четырехмерная агрегация с иерархическими индексами (см. [Иерархическая индексация](pandas_05_hierarchical_indexing.md)), представленная в виде сетки, демонстрирующей взаимосвязь между значениями.


### Дополнительные параметры сводной таблицы

Функция `pivot_table` может принимать множество полезных аргументов.
`fill_value` и `dropna`, связаны с отсутствующими данными и довольно просты для понимания.

Именованный аргумент `aggfunc` определяет, какой тип агрегирования применяется.
По умолчанию это среднее значение.
Как и в GroupBy, спецификация агрегирующей функции должна быть строкой, представляющей один из нескольких распространенных вариантов (например, `'sum'`, `'mean'`, `'count'`, `'min'`, `'max'` и т. д.).
Кроме того, агрегирование может быть задано в виде словаря, сопоставляющего столбец с функцией агрегирования:

```python jupyter={"outputs_hidden": false}
titanic.pivot_table(index='sex', columns='class',
                    aggfunc={'survived':'sum', 'fare':'mean'}, observed=True)
```

Обратите внимание, что здесь было опущено ключевое слово `values`. 
При указании сопоставления для `aggfunc` оно определяется автоматически.

<!-- #region jupyter={"outputs_hidden": true} -->
Иногда полезно подсчитать итоги по каждой группе.
Это можно сделать с помощью ключевого слова `margins`:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
titanic.pivot_table('survived', index='sex', columns='class', margins=True, observed=True)
```

Такие итоги автоматически дают информацию о выживаемости вне зависимости от класса, коэффициенте выживаемости по классу вне зависимости от пола и общем коэффициенте выживаемости 38%. 
Метки для этих итогов можно задать с помощью ключевого слова `margins_name`, по умолчанию имеющего значение 'All'.
