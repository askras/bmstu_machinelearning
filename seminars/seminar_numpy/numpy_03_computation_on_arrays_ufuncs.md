---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Вычисления на массивах NumPy: универсальные функции


NumPy так важен в мире науки о данных Python именно потому, что он предоставляет простой и гибкий интерфейс для оптимизированных вычислений с массивами данных.

Вычисления над массивами NumPy могут быть как очень быстрыми, так и очень медленными.
Ключ к ускорению &mdash; использование *векторизованных* операций, обычно реализуемых с помощью *универсальных функций* (ufuncs) NumPy.
Использование универсальных функций NumPy значительно повышают эффективность повторяющихся вычислений над элементами массива.


## Медлительность циклов

Реализация Python по умолчанию (известная как CPython) выполняет некоторые операции очень медленно.
Отчасти это связано с динамической, интерпретируемой природой языка: типы являются гибкими, поэтому последовательности операций не могут быть скомпилированы в эффективный машинный код, как в случае C или Fortran.

В разное время предпринимались различные попытки устранить эту проблему: 
- проект [PyPy](http://pypy.org/) &mdash; реализация Python, с динамической компиляцией;
- проект [Сython](http://cython.org/), преобразующий код на языке Python в компилируемый код C;
- проект [Numba](http://numba.pydata.org/), преобразующий фрагменты кода Python в быстрый байт-код LLVM.
  
Каждый из них имеет свои сильные и слабые стороны, но можно с уверенностью сказать, что ни один из трех подходов пока не превзошел охват и популярность стандартной реализации CPython.

Относительная медлительность Python обычно проявляется в ситуациях, когда повторяется много мелких операций, например, при циклическом переборе массивов для обработки каждого элемента.
Например, вычислить обратную величину для каждого элемента массива можно так:

```python jupyter={"outputs_hidden": false}
import numpy as np
np.random.seed(42)

def compute_reciprocals(values):
    '''Вычисление обратной величина для всех элементов массив'''
    output = np.empty(len(values))
    for i in range(len(values)):
        output[i] = 1.0 / values[i]
    return output
        
values = np.random.randint(1, 10, size=5)
compute_reciprocals(values)
```

Такая реализация, вероятно, покажется вполне естественной человеку, имеющему опыт работы, скажем, с C или Java.
Но измерение времени выполнения этого кода для большого объема входных данных покажет, что этот код работает очень медленно. Очень, очень, медленно!
Проверим это с помощью магическлой команды IPython &mdash; `%timeit`:

```python jupyter={"outputs_hidden": false}
big_array = np.random.randint(1, 100, size=1000000)
%timeit compute_reciprocals(big_array)
```

Вычисление этих миллионов операций и сохранение результата занимает несколько секунд!
Если учесть, что даже у мобильных телефонов скорость обработки данных измеряется в гигафлопсах (т. е. миллиардах числовых операций в секунду), это кажется почти абсурдно медленным.
Оказывается, узким местом здесь являются не сами операции, а проверка типов и диспетчеризация функций, которые CPython должен выполнять на каждом этапе цикла.
Каждый раз, когда вычисляется обратная величина, Python сначала проверяет тип объекта и выполняет динамический поиск правильной функции для использования для этого типа.
Если бы мы работали с скомпилированным кодом, сведения о типе были бы известна до выполнения кода, и результат можно было бы вычислить гораздо эффективнее.


## Знакомство с UFuncs

Для многих типов операций NumPy предоставляет удобный интерфейс для статически типизированной, скомпилированной процедур, получивший название &mdash; *векторизованная* операция.
Векторизованный подход разработан для переноса цикла в скомпилированный слой, лежащий в основе NumPy, что приводит к значительному ускорению выполнения.

Сравним результаты следующих двух фрагментов кода: 

```python jupyter={"outputs_hidden": false}
print(compute_reciprocals(values))
print(1.0 / values)
```

Замерив время выполнения векторизованного кода можно заметить что он выполняется на порядки быстрее, чем цикл Python:

```python jupyter={"outputs_hidden": false}
%timeit (1.0 / big_array)
```

Векторизованные операции в NumPy реализуются с помощью *ufuncs*, основным назначением которых является быстрое выполнение повторяющихся операций надэлементами массива NumPy.
Ufuncs чрезвычайно гибки &mdash;. 
Они могут реализовывать операции между скаляром и массивом, или работать с двумя массивами:

```python jupyter={"outputs_hidden": false}
np.arange(5) / np.arange(1, 6)
```

Операции ufunc не ограничиваются одномерными массивами &mdash; они также могут работать с многомерными массивами:

```python jupyter={"outputs_hidden": false}
x = np.arange(9).reshape((3, 3))
2 ** x
```

Вычисления с использованием векторизации через ufuncs почти всегда более эффективны, чем их аналоги, реализованные с использованием циклов Python, особенно по мере увеличения размера массивов.
Каждый раз, когда в скрипте Python появляется цикл, следует подумать, можно ли заменить его векторизованным выражением.


## Обзор универсальных функций NumPy

 Универсальные функции существуют в двух разновидностях: *унарные универсальные функции*, которые работают с одним аргументом, и *бинарные универсальные функции*, работающиет с двумя аргументами.
Рассмотрим примеры обоих типов функций.


### Арифметические операции над массивами

Универсальные функции NumPy являются очень простыми в использовании, поскольку используют нативные арифметические операторы Python.
Можно использовать стандартные операции сложения, вычитания, умножения и деления:

```python jupyter={"outputs_hidden": false}
x = np.arange(5)
print("x     =", x)
print("x + 5 =", x + 5)
print("x - 5 =", x - 5)
print("x * 2 =", x * 2)
print("x / 2 =", x / 2)
print("x // 2 =", x // 2)  # разделение этажей
```

Существует также унарная универсальная функция для операции отрицания, оператор `**` для возведения в степень и оператор `%` для деления по модулю (взятия остатка от деления):

```python jupyter={"outputs_hidden": false}
print("-x     = ", -x)
print("x ** 2 = ", x ** 2)
print("x % 2  = ", x % 2)
```

Естественно операции можно объединять по собственному желанию. 
При этом соблюдается стандартный порядок операций:

```python jupyter={"outputs_hidden": false}
-(0.5*x + 1) ** 2
```

Каждая из этих арифметических операций представляет собой просто удобную обертку вокруг определенных функций, встроенных в NumPy; например, оператор `+` является оберткой для функции `add`:

```python jupyter={"outputs_hidden": false}
np.add(x, 2)
```

В следующей таблице перечислены арифметические операторы, реализованные в NumPy:

| Оператор | Эквивалент ufunc   | Описание                             |
|----------|--------------------|------------------------------------- |
| `+`      | `np.add`           |Сложение (например, `1 + 1 = 2`)      |
| `-`      | `np.subtract`      |Вычитание (например, `3 - 2 = 1`)     |
| `-`      | `np.negative`      |Унарное отрицание (например, `-2`)    |
| `*`      | `np.multiply`      |Умножение (например, `2 * 3 = 6`)     |
| `/`      | `np.divide`        |Деление (например, `3 / 2 = 1,5`)     |
| `//`     | `np.floor_divide` |Целочисленное деление (например, `3 // 2 = 1`) |
| `**`     | `np.power`         |Возведение в степень (например, `2 ** 3 = 8`)  |
| `%`      | `np.mod`           |Модуль/остаток (например, `9 % 4 = 1`)         |

Кроме того, существуют булевы/побитовые операторы, которые будут рассмотрены в разделе [Сравнения, маски и булева логика](numpy_06_boolean_arrays_and_masks.md).


### Абсолютное значение

Аналогично тому, как NumPy понимает встроенные арифметические операторы Python, он также понимает встроенную функцию вычисления абсолютного значения Python:

```python jupyter={"outputs_hidden": false}
x = np.array([-2, -1, 0, 1, 2])
abs(x)
```

Соответствующая универсальная функция NumPy &mdash; `np.absolute` также доступна под псевдонимом `np.abs`:

```python jupyter={"outputs_hidden": false}
np.absolute(x)
```

```python jupyter={"outputs_hidden": false}
np.abs(x)
```

Эта функция также может обрабатывать комплексные числа, возвращая их модулль:

```python jupyter={"outputs_hidden": false}
x = np.array([3 - 4j, 4 + 3j, 2 + 0j, 0 - 1j])
np.abs(x)
```

### Тригонометрические функции

NumPy предоставляет большое количество полезных универсальных функций, в том числе &mdash; тригонометрические функции.
Начнем с определения массива углов:

```python jupyter={"outputs_hidden": false}
theta = np.linspace(0, np.pi, 3)
```

Теперь можно вычислить некоторые тригонометрические функции по этим значениям:

```python jupyter={"outputs_hidden": false}
print("theta      = ", theta)
print("sin(theta) = ", np.sin(theta))
print("cos(theta) = ", np.cos(theta))
print("tan(theta) = ", np.tan(theta))
```

Значения вычисляются в пределах точности конкретной вычислительной машины, поэтому значения, которые должны быть равны нулю, не всегда его достигают.


Кочечно же доступны и обратные тригонометрические функции:

```python jupyter={"outputs_hidden": false}
x = [-1, 0, 1]
print("x         = ", x)
print("arcsin(x) = ", np.arcsin(x))
print("arccos(x) = ", np.arccos(x))
print("arctan(x) = ", np.arctan(x))
```

### Экспоненты и логарифмы

Другим распространенным типом операций, реализованными в виде универсальных функций, являются показательные функции:

```python jupyter={"outputs_hidden": false}
x = [1, 2, 3]
print("x     =", x)
print("e^x   =", np.exp(x))
print("2^x   =", np.exp2(x))
print("3^x   =", np.power(3, x))
```

Естественно, реализованы и логарифмы.
Базовая функция `np.log` вычисляет натуральный логарифм. 
Если необходимо вычислить логарифм по основанию 2 или 10, они также доступны:

```python jupyter={"outputs_hidden": false}
x = [1, 2, 4, 10]
print("x        =", x)
print("ln(x)    =", np.log(x))
print("log2(x)  =", np.log2(x))
print("log10(x) =", np.log10(x))
```

Существуют также некоторые специализированные версии, которые возвращают более точные значения при очень малых входных данных:

```python jupyter={"outputs_hidden": false}
x = [0, 0.001, 0.01, 0.1]
print("exp(x) - 1 =", np.expm1(x))
print("log(1 + x) =", np.log1p(x))
```

Если `x` очень мал, эти функции дают более точные значения, чем обычные `np.log` или `np.exp`.


### Специализированные универсальные функции

В NumPy доступно гораздо больше универсальных функций, включая гиперболические тригонометрические функции, побитовую арифметику, операторы сравнения, преобразования из радиан в градусы, округление и остатки и многое другое.
Просмотр документации NumPy расскажет о множестве интересных функций.

Еще одним прекрасным источником более специализированных и малоизвестных универсальных функций является подмодуль `scipy.special`.

При необходимости вычислить какую-то непонятную математическую функцию над имеющимися данными, нужно заглянуть в `scipy.special`, скорее всего, она уже реализована там.
Функций слишком много, чтобы перечислить их все, но в следующем фрагменте показано несколько, которые могут возникнуть в контексте статистических вычислений:

```python jupyter={"outputs_hidden": false}
from scipy import special
```

```python jupyter={"outputs_hidden": false}
# Гамма-функции (обобщенные факториалы) и тому подобные функции
x = [1, 5, 10]
print("gamma(x)     =", special.gamma(x))
print("ln|gamma(x)| =", special.gammaln(x))
print("beta(x, 2)   =", special.beta(x, 2))
```

```python jupyter={"outputs_hidden": false}
# Функция ошибок (интеграл от Гауссовой функции),
# дополнительная и обратная к ней функции
x = np.array([0, 0.3, 0.7, 1.0])
print("erf(x)  =", special.erf(x))
print("erfc(x) =", special.erfc(x))
print("erfinv(x) =", special.erfinv(x))
```

В NumPy и `scipy.special` доступно гораздо больше универсальных функций.
Поскольку документация по этим пакетам доступна в Интернете, поиск в Интернете по запросу &laquo;гамма-функция python&raquo; обычно позволяет найти нужную информацию.


## Расширенные возможности универсальных функций

Многие пользователи NumPy используют универсальные функции, даже не подозревая обо всех их возможностях.
Опишем несколько специализированных возможностей универсальных функций.


### Указание массива для вывода результата

При сложных вычислений иногда полезно иметь возможность указать массив, в котором будет сохранен результат вычисления.
Вместо создания временного массива это позволяет записывать результаты вычислений в требуемое место памяти непосредственно.
Для всех универсальных функций это можно сделать с помощью аргумента `out`:

```python jupyter={"outputs_hidden": false}
x = np.arange(5)
y = np.empty(5)
np.multiply(x, 10, out=y)
print(y)
```

Это работает даже с представлениями массива. 
Например, можно записать результаты вычисления в каждый второй элемент указанного массива:

```python jupyter={"outputs_hidden": false}
y = np.zeros(10)
np.power(2, x, out=y[::2])
print(y)
```

Если вместо этого написать `y[::2] = 2 ** x`, это привет к созданию временного массива для хранения результатов `2 ** x`, за которым последовала бы вторая операция копирования этих значений в массив `y`.
Это не имеет большого значения при малых объемах данных, но для очень больших массивов экономия памяти за счет аккуратного использования аргумента `out` может быть существенной.


### Сводные показатели

Для бинарных универсальных функций существуют возможность вычислять некоторые сводные показатели непосредственно на основе объекта.
Например, при необходимости *редуцировать* массив с помощью определенной операции, можно использовать метод `reduce` соответвтующей универсальной функции.
Операция `reduce` многократно применяет заданную операцию к элементам массива до тех пор, пока не останется только одно значение, которое и будет результатом.

Например, вызов `reduce` для функции `add` возвращает сумму всех элементов в массиве:

```python jupyter={"outputs_hidden": false}
x = np.arange(1, 6)
np.add.reduce(x)
```

Аналогично, вызов `reduce` для функции `multiply` вычислит произведение всех элементов массива:

```python jupyter={"outputs_hidden": false}
np.multiply.reduce(x)
```

Если нужно сохранить все промежуточные результаты вычислений, можно вместо этого использовать `accumulate`:

```python jupyter={"outputs_hidden": false}
np.add.accumulate(x)
```

```python jupyter={"outputs_hidden": false}
np.multiply.accumulate(x)
```

Отметим также, что для этих конкретных случаев существуют специальные функции NumPy (`np.sum`, `np.prod`, `np.cumsum`, `np.cumprod`), которые   рассмотрены в [Агрегирование: минимум, максимум и все, что между ними](numpy_04_computation_on_arrays_aggregates.md).


### Векторные произведения

Наконец, любая универсальная функция может вычислить выходные данные всех пар двух элементов своих аргументов, используя метод `outer`.
Это позволяет в одну строку выполнить такие действия, как создание таблицы умножения:

```python jupyter={"outputs_hidden": false}
x = np.arange(1, 10)
np.multiply.outer(x, x)
```

Методы `ufunc.at` и `ufunc.reduceat`, которые рассмотрены в [ &laquo;Прихотливая&raquo; индексация](numpy_07_fancy_indexing.md), также очень полезны.

Еще одной чрезвычайно полезной особенностью универсальных функцией является возможность работать с массивами разных размеров и форм &mdash; набор операций, известный как *транслирование* (*broadcasting*).
Эта тема настолько важна, что ей посвящен целый раздел (см. [ Операции над массивами: транслирование](numpy_05_computation_on_arrays_broadcasting.md)).


## Узнать больше об универсальных функциях


Более подробную информацию об универсальных функциях (включая полный список доступных функций) можно найти на официальном сайте [NumPy](http://www.numpy.org) и сайте [документации NumPy](https://numpy.org/doc/stable/).

Напомним, что также можно получить доступ к информации непосредственно из IPython, импортировав пакеты и используя функциональность автодополнения и справки (`?`) IPython.
