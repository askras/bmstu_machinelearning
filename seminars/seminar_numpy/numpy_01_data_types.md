---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Типы данных в Python

<!-- #region -->
Эффективная наука и вычисления, основанные на данных, требуют понимания того, как данные хранятся и обрабатываются.
В этом разделе описывается и сравнивается, как обрабатываются массивы данных в самом языке Python, а также отличия и усовершенствования, вносимые в этом процесс пакетом NumPy.
Значение различий очень важно для эффективной работы с данными.

Пользователей Python часто привлекает простота его использования, одним из элементов которой является динамическая типизация.
В то время как статически типизированные языки, такие, например, как C или Java, требует явного объявления каждой переменной, в динамически типизированных языках, к которым относится Python, этого не требуется. 

Например, в C некоторый фрагмент кода можен выглядеть следующим образом:

```C
/* Код на C */
int result = 0;
for(int i=0; i<100; i++){
    result += i;
}
```

В то время как на Python эквивалентную операцию можно записать так:

```python
# Код на Python
result = 0
for i in range(100):
    result += i
```

Обратите внимание на главное отличие: в C типы данных каждой переменной явно объявлены, тогда как в Python типы выводятся динамически. 
Это дает возможность назначить любой тип данных любой переменной.
Например, изменим тип переменной `x` с целочисленного на строковый:

```python
# Код на Python
x = 4
x = "четыре"
```

То же самое в языке C приведет (в зависимости от настроек компилятора) к ошибке компиляции или другим непреднамеренным последствиям:

```C
/* Код на C */
int x = 4;
x = "четыре";  // Ошибка
```

Такая гибкость &mdash; один из факторов, делающих языки с динамической типизацией (в частности  Python) такими удобными и простыми в использовании.
Понимание того, *как* это работает, является важной частью обучения эффективному и действенному анализу данных с помощью Python.
Однако, такая гибкость при работе с типами также указывает на тот факт, что переменные Python &mdash; представляют из себя нечто большее, чем просто значение. 
Они также содержат дополнительную информацию о типе хранящегося значения. 
Рассмотрим этот вопрос подробнее.
<!-- #endregion -->

## Целые числа в Python — это больше, чем просто целые числа

Стандартная реализация Python написана на языке C.
Это означает, что каждый объект Python &mdash; это просто хитро замаскированная структура C, которая содержит не только свое значение, но и другую информацию. 
Например, целое число в Python, например `x = 10000`, `x` &mdash; это не просто &laquo;сырое&raquo; целое число. 
На самом деле это указатель на составную структуру C, которая содержит несколько значений.

Это означает, что при хранении целого числа в Python существуют некоторые избыточность по сравнению с целым числом в компилируемом языке, таком как C, как показано на следующем рисунке:


![Cтруктура данных типа Integer](./img/cint_vs_pyint.png)


Здесь ``PyObject_HEAD`` &mdash; это часть структуры, содержащая счетчик ссылок, код типа и другие вспомогательные части.

Еще раз обратим внимание на то, что целое число в языке C по сути является адресом ячейки памяти, байты в которой кодируют целочисленное значение.
Целое число Python  &mdash; это указатель на позицию в памяти, содержащую всю информацию об объекте Python, включая и байты, кодирующиесодержащие целочисленное значение.
Эта дополнительная информация в целочисленной структуре Python позволяет программировать на Python так свободно и динамично.
Однако вся эта дополнительная информация в типах Python имеет свою цену, что становится особенно очевидным в структурах, объединяющих множество таких объектов.


## Списки Python — это больше, чем просто списки

Рассмотрим теперь, как устроены структуры данных Python, содержащие множество объектов Python.
Стандартным изменяемым многоэлементным контейнером в Python является список (`list`).
Cоздать список целых чисел можно следующим образом:

```python jupyter={"outputs_hidden": false}
L = list(range(10))
L
```

```python jupyter={"outputs_hidden": false}
type(L[0])
```

Аналогично создается список строк:

```python jupyter={"outputs_hidden": false}
L2 = [str(c) for c in L]
L2
```

```python jupyter={"outputs_hidden": false}
type(L2[0])
```

Благодаря динамической типизации Python имеется возможность создавать даже неоднородные (содержащие элементы разных типов) списки:

```python jupyter={"outputs_hidden": false}
L3 = [True, "2", 3.0, 4]
[type(item) for item in L3]
```

Но эта гибкость имеет свою цену: чтобы иметь возможность так легко объединять в одной структуре элементы имеющие разные типы, необходимо, чтобы каждый из них представлял собой полноценный объект Python, то есть содержал собственную информацию о типе, количестве ссылок на него и другую информацию. 
При этом, в  том случае, когда все переменные имеют один и тот же тип, большая часть этой информации избыточна: гораздо эффективнее хранить данные в массиве фиксированного типа, в котором служебная информация об элементах хрнится централизовано, и не дублируется к каждом из них.
Разница между списком динамического типа и массивом фиксированного типа (в стиле NumPy) проиллюстрирована на следующем рисунке:


![Структура данных массив](./img/array_vs_list.png)


На уровне реализации массив по сути содержит один указатель на один непрерывный блок данных.
С другой стороны, список Python содержит указатель на блок указателей, каждый из которых, в свою очередь, указывает на полный объект Python, такой, например, как целое число Python, которое было описано выше.
Преимуществом списка является гибкость: поскольку каждый элемент списка представляет собой полную структуру, содержащую как данные, так и информацию о типе, список можно заполнить данными любого желаемого типа.
Массивы фиксированного типа в стиле NumPy лишены такой гибкости, но гораздо более эффективны для хранения и обработки данных.


## Массивы с фиксированным типом в Python

Python предлагает несколько различных вариантов хранения данных в эффективных буферах данных с фиксированным типом.
Встроенный модуль `array` (доступен с Python 3.3) можно использовать для создания плотных массивов, содержащих элементы одного типа:

```python jupyter={"outputs_hidden": false}
import array
L = list(range(10))
A = array.array('i', L)
A
```

Здесь `i` &mdash; это код типа, указывающий, что элементы массива представляют собой целые числа.

Однако гораздо более удобным и функциональным является объект `ndarray` пакета NumPy.
В то время как объект `array` в Python обеспечивает эффективное хранение данных на основе массива, NumPy добавляет к этому эффективные *операции* с этими данными.
Рассмотрим эти операции далее; здесь же продемонстрируем несколько способов создания массива NumPy.

Начнем со стандартного импорта NumPy под псевдонимом `np`:

```python jupyter={"outputs_hidden": false}
import numpy as np
```

## Создание массивов из списков Python

Массивы NumPy можно создавать из списков Python:

```python jupyter={"outputs_hidden": false}
# Целочисленный массив:
np.array([1, 4, 2, 5, 3])
```

Следует помнить, что в отличие от списков Python, NumPy ограничен массивами, которые содержат элементы одного типа.
Если типы не совпадают, NumPy, если это возможно, выполнит приведение к более широкому типу. Здесь целые числа преобразуются к типу с плавающей точкой:

```python jupyter={"outputs_hidden": false}
np.array([3.14, 4, 2, 3])
```

В следующих двух примерах все элементы будут преобразованы в строки:

```python
np.array([1, 1.0, '1'])
```

```python
np.array([1, 1.0, '1', 'один'])
```

По желанию можно явно задать тип данных результирующего массива, используя для этого ключевое слово `dtype`:

```python jupyter={"outputs_hidden": false}
np.array([1, 2, 3, 4], dtype='float32')
```

```python jupyter={"outputs_hidden": false}
np.array([1, 2, 3, 4], dtype='str')
```

Наконец, в отличие от списков Python, массивы NumPy могут явным образом описываться как многомерные.
Вот один из способов инициализации многомерного массива с помощью списка списков:

```python jupyter={"outputs_hidden": false}
# Вложенные списки приводят к многомерным массивам
np.array([range(i, i + 3) for i in [2, 4, 6]])
```

Вложенные списки рассматриваются как строки результирующего двумерного массива.


## Создание массивов с нуля

Большие массивы эффективнее создавать массивы с нуля, используя встроенные в NumPy процедуры.
Вот несколько примеров:

```python jupyter={"outputs_hidden": false}
# Создание массива целых чисел длиной 10 заполненного нулями
np.zeros(10, dtype=int)
```

```python jupyter={"outputs_hidden": false}
# Создание массива 3x5 вещественных чисел заполненного единицами
np.ones((3, 5), dtype=float)
```

```python jupyter={"outputs_hidden": false}
# Создание массива 3x5 заполненного приближение числа Пи
np.full((3, 5), 3.14)
```

```python jupyter={"outputs_hidden": false}
# Создание массива заполненного линейной последовательностью
# начиная с 0, заканчивая 20, с шагом 2
# (похоже на встроенную функцию range())
np.arange(0, 20, 2)
```

```python jupyter={"outputs_hidden": false}
# Создание массива из пяти значений равномерно распределенных между 0 и 1.
np.linspace(0, 1, 5)
```

```python jupyter={"outputs_hidden": false}
# Создание массива 3x3 равномерно распределенных случайных чисел от 0 до 1
np.random.random((3, 3))
```

```python jupyter={"outputs_hidden": false}
# Создание массива 3x3 нормально распределенных случайных чисел
# со средним значением 0 и стандартным отклонением 1
np.random.normal(0, 1, (3, 3))
```

```python jupyter={"outputs_hidden": false}
# Создание массива 3x3 случайных целых чисел в интервале [0, 10)
np.random.randint(0, 10, (3, 3))
```

```python jupyter={"outputs_hidden": false}
# Создание единичной матрицы 3x3
np.eye(3)
```

```python jupyter={"outputs_hidden": false}
# Создание неинициализированного массива из трех целых чисел
# Значениями будут произвольные, случайно оказавшиеся в данных ячейках памяти числа
np.empty(3)
```

## Стандартные типы данных NumPy

Массивы NumPy содержат значения одного  простого типа, поэтому для правильного выбора типа элементов, важно знать все их особенности и ограничения.
Поскольку NumPy написан на языке C, типы будут знакомы пользователям C.

Стандартные типы данных NumPy перечислены в следующей таблице.
Обратите внимание, что при создании массива, тип элементов можно указать или помощью строки:

```python
np.zeros(10, dtype='int16')
```

или с помощью связанного объекта NumPy:

```python
np.zeros(10, dtype=np.int16)
```

| Тип данных  | Описание    |
|-------------|-------------|
| `bool_`     | Логическое значение (True или False), хранящееся в виде байта |
| `int_`      | Целочисленный тип по умолчанию (такой же, как в C `long`; обычно `int32` или `int64`)|
| `intc`      | Идентично C `int` (обычно `int32` или `int64`)|
| `intp`      | Целое число, используемое для индексации (то же, что и `ssize_t` в C; обычно `int32` или `int64`)|
| `int8`      | Байт (от -128 до 127)|
| `int16`     | Целое число (от -32768 до 32767)|
| `int32`     | Целое число (от -2147483648 до 2147483647)|
| `int64`     | Целое число (от -9223372036854775808 до 9223372036854775807)|
| `uint8`     | Беззнаковое целое число (от 0 до 255)|
| `uint16`    | Беззнаковое целое число (от 0 до 65535)|
| `uint32`    | Беззнаковое целое число (от 0 до 4294967295)|
| `uint64`    | Беззнаковое целое число (от 0 до 18446744073709551615)|
| `float_`    | Сокращение для `float64`.|
| `float16`   | Число с плавающей точкой половинной точности: знаковый бит, 5 бит экспонента, 10 бит мантисса|
| `float32`   | Число с плавающей точкой одинарной точности: знаковый бит, 8 бит экспоненты, 23 бита мантиссы|
| `float64`   | Чисто с плавающей точкой двойной точности: знаковый бит, 11 бит экспоненты, 52 бита мантиссы|
| `complex_`  | Сокращение для `complex128`.|
| `complex64` | Комплексное число, представленное двумя 32-битными числами с плавающей точкой|
| `complex128`| Комплексное число, представленное двумя 64-битными числами с плавающей точкой|


Возможна более сложная спецификация типов, например, указание прямого или обратного порядка байт.
Для получения дополнительной информации смотрите [документацию NumPy](https://numpy.org/doc/stable/ "Документация NumPy").

NumPy также поддерживает составные типы данных, которые будут рассмотрены далее.
