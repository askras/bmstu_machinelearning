---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Сравнения, маски и булева логика


В этом разделе рассматривается использование булевых масок для просмотра и изменения значений в массивах NumPy.
Маскирование удобно при изменении, подсчета, просмотра или других манипуляций со значениями в массиве на основе некоторого критерия. Например, при необходимости подсчитать все значения, превышающие определенное значение, или, удалить все выбросы, которые превышают некоторый порог.
В NumPy булевы маски часто являются наиболее эффективным способом выполнения задач такого типа.


## Пример: подсчет дождливых дней

Пусть имеется ряд данных, отражающих облачность каждый день в течение года в определенном городе.
Например, рассмотрим ежедневную статистику погоды для Москвы за 2023 год (данные получены из сервиса https://arhivpogodi.ru/):

```python
import numpy as np
```

```python
weather_moscow_2023 = np.loadtxt("./weather_moscow_2023.csv",
                                 delimiter=";",  # разделитель значений
                                 dtype=str)      # получить данные в текстовом формате
weather_moscow_2023
```

Выберем данные об облачности

```python
cloud_cover = weather_moscow_2023[1:,6].astype(np.float64)
cloud_cover
```

Итак, массив `cloud_cover` содержит 365 значений, показывающих облачность в процентах каждый день в полдень с 1 января по 31 декабря 2023 года.

Для первого быстрого знакомства с данными построим с помощью Matplotlib гстограмму облачных:

```python jupyter={"outputs_hidden": false}
%matplotlib inline
import matplotlib.pyplot as plt
```

```python jupyter={"outputs_hidden": false}
plt.hist(cloud_cover, 30);
```

Эта гистограмма дает общее представление о том, как выглядят данные: почти половина дней 2023 года были пасмурными.
Но это не очень хорошо передает некоторую информацию, которую хотелось бы видеть: например, сколько ясных дней было в году? Сколько дней было с облачностью более 50%?


### Изучение данных

Одним из подходов к решению этой проблемы было бы ответить на эти вопросы вручную: выполнить цикл по данным, увеличивая счетчик каждый раз, когда найдено очередное значение в некотором желаемом диапазоне.
Но данный подход крайне неэффективен как с точки зрения времени написания кода, так и времени вычисления результата.
В [Вычисления на массивах NumPy: универсальные функции](numpy_03_computation_on_arrays_ufuncs.md) было показано, что универсальные функции NumPy можно использовать вместо циклов для выполнения быстрых поэлементных арифметических операций с массивами; таким же образом можно использовать другие универсальные функции для выполнения поэлементных *сравнений* массивов, а затем обрабатывать результаты, чтобы ответить на имеющиеся  вопросы.
Отложим пока данные в сторону и обсудим некоторые общие инструменты в NumPy, позволяющие использовать *маскирование* для быстрого ответа на вопросы такого типа.


## Операторы сравнения как универсальные функции

В  [Вычисления на массивах NumPy: универсальные функции](numpy_03_computation_on_arrays_ufuncs.md) показано, что применение операторов `+`, `-`, `*`, `/` к массивам приводит к поэлементным операциям.
NumPy также реализует операторы сравнения, такие как `<` (меньше чем) и `>` (больше чем) как поэлементные универсальные функции.
Результатом этих операторов сравнения всегда является массив с логическим типом данных.
Доступны все шесть стандартных операций сравнения:

```python
x = np.array([1, 2, 3, 4, 5])
```

```python jupyter={"outputs_hidden": false}
x < 3  # меньше, чем
```

```python jupyter={"outputs_hidden": false}
x > 3  # больше чем
```

```python jupyter={"outputs_hidden": false}
x <= 3  # меньше или равно
```

```python jupyter={"outputs_hidden": false}
x >= 3  # больше или равно
```

```python jupyter={"outputs_hidden": false}
x != 3  # не равны
```

```python jupyter={"outputs_hidden": false}
x == 3  # равны ли
```

Также возможно выполнять поэлементное сравнение двух массивов и использовать составные выражения:

```python jupyter={"outputs_hidden": false}
(2 * x) == (x ** 2)
```

Как и в случае арифметических операторов, операторы сравнения реализованы в NumPy как универсальные функции; например, при выполнении сравнения `x < 3`, на самом деле вызывается функция `np.less(x, 3)`.
Ниже приведен обзор операторов сравнения и их эквивалентных функций:

| Оператор | Эквивалентная универсальная функция|
|----------|------------------------------------|
| `==`     | `np.equal`                         |
| `!=`     | `np.not_equal`                     |
| `<`      | `np.less`                          |
| `<=`     | `np.less_equal`                    |
| `>`      | `np.greater`                       |
| `>=`     | `np.greater_equal`                 |


Как и в случае арифметических универсальных функций, они будут работать с массивами любого размера и формы.
Вот двумерный пример:

```python jupyter={"outputs_hidden": false}
rng = np.random.RandomState(0)
x = rng.randint(10, size=(3, 4))
x
```

```python jupyter={"outputs_hidden": false}
x < 6
```

В каждом случае результатом является логический массив, и NumPy предоставляет ряд простых методов для работы с этими логическими результатами.


## Работа с булевыми массивами

Имея булев массив, можно выполнить множество полезных операций.
Рассмотрим опримеры на основе работы с двумерным массивом `x`, который мы создали ранее.

```python jupyter={"outputs_hidden": false}
print(x)
```

### Подсчет записей

Для подсчета количества записей ``True`` в логическом массиве полезно удобно `np.count_nonzero`:

```python jupyter={"outputs_hidden": false}
# сколько значений меньше 6?
np.count_nonzero(x < 6)
```

Итак, имеется восемь элементов массива, которые меньше 6.
Другой способ получить эту информацию &mdash; использовать `np.sum`; 
в этом случае `False` интерпретируется как `0`, а `True` интерпретируется как `1`:

```python jupyter={"outputs_hidden": false}
np.sum(x < 6)
```

Преимущество ``sum()`` в том, что, как и в случае с другими функциями агрегирования,  суммирование можно выполнять отдельно по строкам или столбцам :

```python jupyter={"outputs_hidden": false}
# сколько значений меньше 6 в каждой строке?
np.sum(x < 6, axis=1)
```

Если нужно быстро проверить, являются ли некоторые или все значения истинными, можно использовать `np.any` или `np.all`:

```python jupyter={"outputs_hidden": false}
# есть ли значения больше 8?
np.any(x > 8)
```

```python jupyter={"outputs_hidden": false}
# есть ли значения меньше нуля?
np.any(x < 0)
```

```python jupyter={"outputs_hidden": false}
# все ли значения меньше 10?
np.all(x < 10)
```

```python jupyter={"outputs_hidden": false}
# все ли значения равны 6?
np.all(x == 6)
```

`np.all` и `np.any` также могут использоваться вдоль определенных осей. 
Например:

```python jupyter={"outputs_hidden": false}
# все ли значения в каждой строке меньше 8?
np.all(x < 8, axis=1)
```

Здесь все элементы в первой и третьей строках меньше 8, тогда как для второй строки это не так.


Предупреждение: как упоминалось в [Агрегирование: минимум, максимум и все, что между ними](numpy_04_computation_on_arrays_aggregates.md), в Python имеются встроенные функции `sum()`, `any()` и `all()`. 
Они имеют синтаксис, отличный от синтаксиса аналогичных версий NumPy, и, в частности, будут давать сбой или непреднамеренные результаты при использовании с многомерными массивами. 


### Булевы операторы

Теперь легко подсчитать, скажем, ясные дни, с облачностью менее 20%: 

```python
np.sum(cloud_cover < 20)
```

или все дни с облачность более 50%:

```python
np.sum(cloud_cover > 50)
```

Но что делать, если необходимо выяснить количество дней когда облачности составлял от 20 до 30 процентов?
Это достигается с помощью *побитовых логических операторов* (*bitwise logic operators*) Python: `&`, `|`, `^` и `~`.
Как и в случае со стандартными арифметическими операторами, NumPy перегружает их как универсальные функции, которые работают поэлементно с массивами (обычно булевыми).

Например, можно ответить на поставленный выше вопрос следующим образом:

```python jupyter={"outputs_hidden": false}
np.sum((cloud_cover >= 20) & (cloud_cover <= 50))
```

<!-- #region -->
То есть 41 день в течение года процент облачности в Москве составлял от 20 до 30 процентов.

Следует обратить внимание, что скобки в выражении выше очень важны в силу правил приоритета операторов. 
Если убрать скобки, это выражение будет вычисляться следующим образом:

``` python
cloud_cover >= (20 & cloud_cover) <= 30
```
что приведет к ошибке.
<!-- #endregion -->

Совместное использование операторов сравнения и булевых операторов при работе с массивами может привести к широкому спектру эффективных логических операций.


В следующей таблице приведены побитовые булевы операторы и их эквивалентные универсальные функции:


| Оператор      | Эквивалентная универсальная функция |
|---------------|-------------------------------------|
| `&`           | `np.bitwise_and`                    |
| &#124;        | `np.bitwise_or`                     |
| `^`           | `np.bitwise_xor`                    |
| `~`           | `np.bitwise_not`                    |


Используя эти инструменты, можно начать отвечвть на вопросы возникающие относительно данных о погоде.
Вот несколько примеров результатов, которые можно вычислить при комбинировании маскирования с агрегирования:

```python jupyter={"outputs_hidden": false}
print('Количество ясных дней:', np.sum(cloud_cover == 0))
print('Количество дней с легкой облачностью:', np.sum(( cloud_cover > 0) & (cloud_cover < 20)))
print('Количество пасмурных дней:', np.sum(cloud_cover > 50))
```

## Булевы массивы как маски

В предыдущем разделе были рассмотрели агрегаторы, вычисляемые непосредственно на булевых массивах.
Гораздо больше возможностей дает использование булевых массивов в качестве масок для выбора определенных подмножеств самих данных.
Возвращаясь к массиву `x`, предположим, что из него нужно получить массив всех, которые меньше, скажем, 5:

```python jupyter={"outputs_hidden": false}
x
```

Получим булев массив для этого условия:

```python jupyter={"outputs_hidden": false}
x < 5
```

Теперь, чтобы *выбрать* нужные значения из массива, достаточно просто проиндексировать исходный массив `x` по полученному булеву массиву.
Данный прием называется *маскирование*:

```python jupyter={"outputs_hidden": false}
x[x < 5]
```

## Отступление: использование ключевых слов and/or операторов &/|

Одной из распространенных путаниц является разница между ключевыми словами `and` и `or`, с одной стороны, и операторами `&` и `|` с другой.
Когда следует использовать один вариант, а когда другой?

Разница заключается в следующем: `and` и `or` оценивают истинность или ложность *всего объекта*, тогда как `&` и `|` оперируют  *отдельными битам внутри каждого объекта*.

Использование `and` или `or` заставляет Python рассматривать объект как одну логическую сущность.
В Python все ненулевые целые числа оцениваются как True. 
Таким образом:

```python jupyter={"outputs_hidden": false}
bool(42), bool(0)
```

```python jupyter={"outputs_hidden": false}
bool(42 and 0)
```

```python jupyter={"outputs_hidden": false}
bool(42 or 0)
```

При использовании `&` и `|` с целыми числами выражение действует на биты элемента, применяя `and` или `or` к отдельным битам, составляющим число:

```python jupyter={"outputs_hidden": false}
bin(42)
```

```python jupyter={"outputs_hidden": false}
bin(59)
```

```python jupyter={"outputs_hidden": false}
bin(42 & 59)
```

```python jupyter={"outputs_hidden": false}
bin(42 | 59)
```

Обратите внимание, что для получения результата сравниваются соответствующие биты двоичного представления.

Массив логических значений в NumPy можно рассматривать как строку битов, где `1 = True` и `0 = False`, а результат `&` и `|` действует аналогично вышеприведенному:

```python jupyter={"outputs_hidden": false}
A = np.array([1, 0, 1, 0, 1, 0], dtype=bool)
B = np.array([1, 1, 1, 0, 1, 1], dtype=bool)
A | B
```

Использование `or` для этих массивах приведет к попытке вычисления истинности или ложности всего объекта массива, который не является четко определенным значением, а потому приведет к исключению:

```python jupyter={"outputs_hidden": false}
%%capture
A or B
```

При создании логического выражения для заданного массива следует использовать операторы `|` или `&`, а не операции `or` или `and`:

```python jupyter={"outputs_hidden": false}
x = np.arange(10)
(x > 4) & (x < 8)
```

Попытка оценить истинность или ложность всего массива приведет к той же ошибке `ValueError`, как и в примере выше:

```python jupyter={"outputs_hidden": false}
%%capture
(x > 4) and (x < 8)
```

Итак, `and` и `or` выполняют одну логическую оценку всего объекта, тогда как `&` и `|` выполняют  логических оценок для содержимого (отдельных битов или байтов) объекта.
Для булевых массивов NumPy почти всегда является предпочтительной последняя операция.
