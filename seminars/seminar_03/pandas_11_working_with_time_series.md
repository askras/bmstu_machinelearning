---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Работа с временными рядами


Pandas был разработан в расчете на построение финансовых моделей, поэтому, как и следовало ожидать, он содержит довольно обширный набор инструментов для работы с датами, временем и данными, индексированными по времени.
Данные о дате и времени бывают нескольких видов:

- *Метки даты/времени* ссылаются на определенные моменты времени (например, 1 октября 2024 г. в 7:00 утра).
- *Временные интервалы* и *периоды* обозначают промежуток времени между определенной начальной и конечной точкой (например, 2023 год). Периоды обычно обозначают особый случай временных интервалов, в котором каждый интервал имеет одинаковую длину и не перекрывается (например, 24-часовые периоды, соствавляющие сутки).
- *Временная дельта* или *продолжительность* указывает на отрезок конкретной длительности (например, 14,28 секунды).

В этом разделе рассмотрим, как работать с каждым из этих типов данных даты/времени в Pandas.
Начнем с краткого обсуждения инструментов для работы с датами и временем в Python, а затем перейдем более конкретно к обсуждению инструментов, предоставляемых Pandas.


## Даты и время в Python

В Python имеется несколько вариантов представления дат, времени, дельт и временных интервалов.
Хотя инструменты для обработки временных рядов, предоставляемые Pandas, как правило, наиболее часто используются в приложениях анализа данных, полезно увидеть их связь с другими пакетами, используемыми в Python.


### Форматы даты и время Python: `datetime` и `dateutil`

Базовые объекты Python для работы с датами и временем собраны во встроенном модуле `datetime`.
Вместе со сторонним модулем `dateutil` его можно использовать для быстрого выполнения множества полезных функций с датами и временем.
Например, можно вручную сформировать дату, используя тип `datetime`:

```python jupyter={"outputs_hidden": false}
from datetime import datetime
datetime(year=2024, month=10, day=1)
```

Или, используя модуль `dateutil`, можно выполнять синтаксический разбор дат, представленных в различных строковых представлениях:

```python jupyter={"outputs_hidden": false}
from dateutil import parser
date = parser.parse("1st of October, 2024")
date
```

<!-- #region jupyter={"outputs_hidden": false} -->
Получив объект `datetime`, можно вычислить день недели:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
date.strftime('%A')
```

В последней строке использован один из стандартных кодов формата строки для печати дат (`'%A'`), поднобнее о котором можно прочитать в [strftime section](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) документации Python.
Документацию по другим полезным утилитам для работы с датами можно найти в [dateutil's online documentation](http://labix.org/python-dateutil).
Еще один полезный пакет, о котором следует знать, &mdash; [`pytz`](https://pythonhosted.org/pytz/), который содержит инструменты для работы c часовыми поясами.

Сила пакетов `datetime` и `dateutil` заключается в их гибкости и простом синтаксисе.
Единственное, в чем они работают плохо, это работа с большими массивами дат и времени.
Так же, как списки числовых переменных Python неоптимальны по сравнению с типизированными числовыми массивами в стиле NumPy, списки объектов Python datetime неоптимальны по сравнению с типизированными массивами закодированных дат.


### Типизированные массивы значений времени: `datetime64` в NumPy

Слабые стороны формата даты и времени Python побудили команду NumPy добавить в NumPy набор собственных типов данных временных рядов.
Тип данных `datetime64` кодирует даты как 64-битные целые числа и, таким образом, позволяет представлять массивы дат очень компактно.
`datetime64` требует очень специфичного формата ввода:

```python jupyter={"outputs_hidden": false}
import numpy as np
date = np.array('2024-10-01', dtype=np.datetime64)
date
```

Но как только дата отформатирована, можно быстро выполнять над ней различные векторизованные операции:

```python jupyter={"outputs_hidden": false}
date + np.arange(12)
```

Поскольку datetime64-массивы библиотеки NumPy содержат данные одного типа, этот тип операций может быть выполнен гораздо быстрее, чем если бы производилась работа напрямую с объектами `datetime` в Python, особенно когда массивы становятся большими.

Одной из особенностей объектов `datetime64` и `timedelta64` является то, что они основаны на *базовой единице времени* (*fundamental time unit*).
Поскольку объект `datetime64` ограничен 64-битной точностью, диапазон кодируемых времен составляет $2^{64}$, умноженных на эту фундаментальную единицу.
Другими словами, `datetime64` накладывает компромисс между *разрешающей способностью по времени* и *максимальным промежутком времени*.

Например, если необходимо временное разрешение в одну наносекунду, то возможно закодировать диапазон в $2^{64}$ наносекунд, или чуть менее 600 лет.
NumPy определяет нужную единицу измерения из входных данных; например, вот  вот дата/время на основе единицы в один день:

```python jupyter={"outputs_hidden": false}
np.datetime64('2024-10-01')
```

Вот дата/время на основе единицы в одну минуту::

```python jupyter={"outputs_hidden": false}
np.datetime64('2024-10-01 12:00')
```

Обратите внимание, что часовой пояс автоматически устанавливается на местное время компьютера, выполняющего код.
Можно принудительно задать любую желаемую фундаментальную единицу, используя один из многих кодов формата.
Например, здесь принудительно задается время на основе наносекунд:

```python jupyter={"outputs_hidden": false}
np.datetime64('2024-10-01 12:59:59.50', 'ns')
```

В следующей таблице перечислены доступные коды форматов, а также относительные и абсолютные временные интервалы, которые они могут кодировать:


|Код | Значение | Временной промежуток (относительный) | Временной промежуток (абсолютный) |
|--------|-------------|----------------------|------------------------|
| ``Y`` | Год | ± 9.2e18 лет | [9.2e18 до н.э., 9.2e18 н.э.] |
| ``M`` | Месяц | ± 7.6e17 лет | [7.6e17 до н.э., 7.6e17 н.э.] |
| ``W`` | Неделя | ± 1.7e17 лет | [1.7e17 до н.э., 1.7e17 н.э.] |
| ``D`` | День | ± 2.5e16 лет | [2.5e16 до н.э., 2.5e16 н.э.] |
| ``h`` | Час | ± 1.0e15 лет | [1.0e15 до н.э., 1.0e15 н.э.] |
| ``m`` | Минута | ± 1.7e13 лет | [1.7e13 до н.э., 1.7e13 н.э.] |
| ``s`` | Секунда | ± 2.9e12 лет | [ 2.9e9 до н.э., 2.9e9 н.э.] |
| ``мс`` | Миллисекунда | ± 2.9e9 лет | [ 2.9e6 до н.э., 2.9e6 н.э.] |
| ``us`` | Микросекунда | ± 2.9e6 лет | [290301 до н.э., 294241 н.э.] |
| ``нс`` | Наносекунда | ± 292 года | [ 1678 г. н.э., 2262 г. н.э.] |
| ``пс`` | Пикосекунда | ± 106 дней | [ 1969 н.э., 1970 н.э.] |
| ``fs`` | Фемтосекунда | ± 2,6 часа | [ 1969 н.э., 1970 н.э.] |
| ``as`` | Аттосекунда | ± 9,2 секунды | [ 1969 г. н.э., 1970 г. н.э.] |


Удобное значение по умолчанию для типов данных, встречающихся в реальном мире, &mdash; `datetime64[ns]`, позволяющее кодировать достаточный диапазон современных дат с высокой точностью

Наконец, отметим, что хотя тип данных `datetime64` устраняет некоторые недостатки встроенного в Python типа `datetime`, в нем отсутствуют многие удобные методы и функции, предоставляемые `datetime` и особенно `dateutil`.
Более подробную информацию можно найти в документации [NumPy's datetime64](http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html).


### Даты и время в Pandas: лучшее из обоих миров

Pandas основывается на всех только что рассмотренных инструментах и предоставляет объект `Timestamp`, который сочетает в себе простоту использования `datetime` и `dateutil` с эффективным хранилищем и векторизованным интерфейсом `numpy.datetime64`.
Библиотека Pandas умеет создавать из нескольких таких объектов `Timestamp` объект класса `DatetimeIndex`, который можно использовать для индексации данных в объектах `Series` или `DataFrame`. 

Например, можно использовать инструменты Pandas, чтобы повторить примеры, показанные выше.
Можно выполнить синтаксический разбор строки с датой в гибком формате и воспользоваться кодами форматирования, чтобы вывести день недели:

```python jupyter={"outputs_hidden": false}
import pandas as pd
date = pd.to_datetime("1st of October, 2024")
date
```

```python jupyter={"outputs_hidden": false}
date.strftime('%A')
```

Кроме того, можно выполнять векторные операции в стиле NumPy непосредственно над этим же объектом:

```python jupyter={"outputs_hidden": false}
date + pd.to_timedelta(np.arange(12), 'D')
```

## Временные ряды Pandas: индексация по времени

Инструменты временных рядов Pandas становятся по-настоящему полезными, если *индексировать данные по временным меткам*.
Например, можно создать объект `Series`, содержащий данные, индексированные по времени:

```python jupyter={"outputs_hidden": false}
index = pd.DatetimeIndex(['2024-07-01', 
                          '2024-08-01',
                          '2024-09-01', 
                          '2024-10-01',
                          '2024-11-01',
                          '2024-12-01',
                          '2025-01-01',
                          '2025-02-01',
                         ])
data = pd.Series([0, 1, 2, 3, 4, 6, 6, 7], index=index)
data
```

Теперь, когда данные находятся в объекте `Series`, можно использовать для них любые из обсуждавшихся в предыдущих разделах паттернов индексации `Series`,
передавая значения, которые допускают приведение к типу даты:

```python jupyter={"outputs_hidden": false}
data['2024-07-01':'2024-09-01']
```

Существуют дополнительные специальные операции индексации, работающие только с датами.
Например, можно указать год для получения среза всех данных за этот год:

```python jupyter={"outputs_hidden": false}
data['2025']
```

## Структуры данных временных рядов Pandas

Основные структуры данных Pandas для работы с данными временных рядов:

- Для *меток даты/времени* Pandas предоставляет тип `Timestamp`. Как упоминалось ранее, это по сути замена родного `datetime` Python, но основанный на более эффективном типе данных `numpy.datetime64`. Соответствующая структура индекса &mdash; `DatetimeIndex`.
- Для *периодов времени* Pandas предоставляет тип данных `Period`. Этот тип данных основан на `numpy.datetime64`, он кодирует интервал фиксированной переодичности. Соответствующая структура индекса &mdash; `PeriodIndex`.
- Для *временных дельт* или *продолжительностей* Pandas предоставляет тип `Timedelta`. `Timedelta` является более эффективной заменой родного типа Python `datetime.timedelta` и основан на `numpy.timedelta64`. Соответствующая структура индекса &mdash; `TimedeltaIndex`.


Наиболее фундаментальными из этих объектов даты/времени являются объекты `Timestamp` и `DatetimeIndex`.
Хотя эти объекты можно вызывать напрямую, чаще для этого используется функция `pd.to_datetime()`, которая может анализировать широкий спектр форматов.
Передача одной даты в `pd.to_datetime()` возвращает `Timestamp`; передача серии дат по умолчанию возвращает `DatetimeIndex`:

```python jupyter={"outputs_hidden": false}
dates = pd.to_datetime([datetime(2024, 9, 30), 
                        '1st of October, 2024',
                       '2024-Oct-3', '05-10-2024', '20241008'])
dates
```

Любой `DatetimeIndex` можно преобразовать в `PeriodIndex` с помощью функции `to_period()`, указав код для переодичности интевала.
Используем `'D'` для задания переодичности интервала в один день:

```python jupyter={"outputs_hidden": false}
dates.to_period('D')
```

Объект `TimedeltaIndex` создается, когда одна дата вычитается из другой:

```python jupyter={"outputs_hidden": false}
dates - dates[0]
```

### Регулярные последовательности: функция `pd.date_range()`

Чтобы сделать создание регулярных последовательностей дат более удобным, Pandas предлагает несколько функций: `pd.date_range()` для временных меток, `pd.period_range()` для периодов и `pd.timedelta_range()` для временных дельт.
`pd.date_range()` принимает начальную дату, конечную дату и необязательный код переодичности для создания регулярной последовательности дат.
По умолчанию частота составляет один день:

```python jupyter={"outputs_hidden": false}
pd.date_range('2024-10-03', '2024-10-10')
```

В качестве альтернативы диапазон дат можно указать не с начальной и конечной точкой, а с начальной точкой и количеством периодов:

```python jupyter={"outputs_hidden": false}
pd.date_range('2024-10-03', periods=8)
```

Интервал можно изменить, изменив аргумент `freq`, который по умолчанию равен `'D'`.
Например, построим диапазон почасовых временных меток:

```python jupyter={"outputs_hidden": false}
pd.date_range('2024-10-03', periods=8, freq='h')
```

Для создания регулярных последовательностей значений `Period` или `Timedelta` полезны очень похожие функции `pd.period_range()` и `pd.timedelta_range()`.
Вот некоторые ежемесячные периоды:

```python jupyter={"outputs_hidden": false}
pd.period_range('2024-07', periods=8, freq='M')
```

И последовательность продолжительностей, увеличивающихся на час:

```python jupyter={"outputs_hidden": false}
pd.timedelta_range(0, periods=10, freq='h')
```

## Частоты и смещения

Периодичность или смещение даты &mdash; базовое понятие для инструментов библиотеки Pandas, необходимых для работы с временными рядами.
Так же, как мы видели выше коды ``D`` (день) и ``H`` (час), мы можем использовать такие коды для указания любого желаемого интервала частот.
В следующей таблице приведены основные доступные коды:


| Код | Описание |
|--------|---------------------|
| `D` | Календарный день |
| `W` | Еженедельно | 
| `M` | Конец месяца | 
| `Q` | Конец квартала | 
| `Y` | Конец года | 
| `h` | Часы работы | 
| `min` | Минуты | 
| `s` | Секунды | 
| `ms` | Миллисекунды |
| `us` | Микросекунды |
| `ns` | наносекунды | 


Периодичность в месяц, квартал и год определяется на конец соответствующего периода.


Для частоты 2 часа 30 минут мы можем объединить коды часов (`h`) и минут (`min`) следующим образом:

```python jupyter={"outputs_hidden": false}
pd.timedelta_range(0, periods=9, freq='2h30min')
```

Все эти короткие коды относятся к конкретным случаям смещений временных рядов Pandas, которые можно найти в модуле `pd.tseries.offsets`.
Например, можно создать смещение рабочего дня напрямую следующим образом:

```python jupyter={"outputs_hidden": false}
from pandas.tseries.offsets import BDay
pd.date_range('2024-10-01', periods=5, freq=BDay())
```

Более подробную информацию смотрите в разделе [Offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases) документации Pandas.
