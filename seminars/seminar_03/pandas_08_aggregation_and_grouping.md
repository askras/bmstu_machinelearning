---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Агрегирование и группировка

<!-- #region jupyter={"outputs_hidden": true} -->
Важной частью анализа больших объемов данных является эффективное обобщение: вычисление вычисление сводных показателей, таких как `sum()`, `mean()`, `median()`, `min()` и `max()`, в которых одно число дает представление о природе, возможно, огромного набора данных.
В этом разделе рассмотрим способы расчета сводных показателей в Pandas, от простых операций, подобных тем, что имеют место в массивах NumPy, до более сложных операций, основанных на концепции `groupby`.
<!-- #endregion -->

Для удобства воспользуемся тем же классом `Display`, который определили в предыдущих разделах:

```python
import numpy as np
import pandas as pd
```

```python
class Display:
    '''Создает HTML-представление нескольких объектов'''
    template = """<div style="float: left; padding: 10px;">
    <p style='font-family:"Courier New", Courier, monospace'>{0}</p>{1}
    </div>"""
    def __init__(self, *args):
        self.args = args
        
    def _repr_html_(self):
        return '\n'.join(self.template.format(a, eval(a)._repr_html_()) for a in self.args)
    
    def __repr__(self):
        return '\n\n'.join(a + '\n' + repr(eval(a)) for a in self.args)
```

## Данные о планетах

Здесь мы будем использовать набор данных Planets, доступный в пакете [Seaborn](http://seaborn.pydata.org/).
Он предоставляет информацию о планетах, которые астрономы открыли вокруг других звезд (известных как *внесолнечные планеты* или *экзопланеты*). 
Загрузить этот набор данных можно с помощью простой команды Seaborn:

```python jupyter={"outputs_hidden": false}
import seaborn as sns
planets = sns.load_dataset('planets')
planets.shape
```

```python jupyter={"outputs_hidden": false}
planets.head()
```

Этот набор данных содержит некоторые сведения о более чем 1000 открытых экзопланет:

```python
planets.info()
```

## Простое агрегирование в Pandas


Как и в случае с одномерными массивами NumPy, для одномерных объектов `Series` агрегирующие функции возвращают скалярное значение значение:

```python jupyter={"outputs_hidden": false}
rng = np.random.RandomState(42)
ser = pd.Series(rng.rand(5))
ser
```

```python jupyter={"outputs_hidden": false}
ser.sum()
```

```python jupyter={"outputs_hidden": false}
ser.mean()
```

Для `DataFrame` по умолчанию агрегирующие функции возвращают сводные показатели по каждому столбцу:

```python jupyter={"outputs_hidden": false}
df = pd.DataFrame({'A': rng.rand(5),
                   'B': rng.rand(5)})
df
```

```python jupyter={"outputs_hidden": false}
df.mean()
```

Указав аргумент `axis`, можно выполнить агрегирование в каждой строке:

```python jupyter={"outputs_hidden": false}
df.mean(axis='columns')
```

Объекты `Series` и `DataFrame` библиотеки Pandas поддерживают все методы агрегировани, упомянутые в [Агрегирование: минимум, максимум и все, что между ними](numpy_04_computation_on_arrays_aggregates.md); кроме того, существует удобный метод `describe()`, который вычисляет несколько общих сводных показателей для каждого столбца и возвращает результат.
Опробуем его на наборе данных Planets, временно отбросив строки с пропущенными значениями:

```python jupyter={"outputs_hidden": false}
planets.dropna().describe()
```

Такая возможность может оказаться полезным способом первоначального знакомства с общими свойствами набора данных.
Например, из столюбца `year` видно, что, экзопланеты были впервые открыты еще в 1989 году, но половина всех известных экзопланет была открыта только в 2010 году или позже.
Во многом это произошло благодаря миссии *Кеплер*, которая представляет собой космический телескоп, специально разработанный для поиска затмений от планет, вращающихся вокруг своих звезд.


В следующей таблице приведены некоторые встроенные методы агрегирования пакета Pandas:

| Агрегация | Описание |
|-----------|----------|
| `count()` | Общее количество элементов |
| `first()`, `last()` | Первый и последний элементы |
| `mean()`, `median()` | Среднее и медиана |
| `min()`, `max()` | Минимум и максимум |
| `std()`, `var()` | Стандартное отклонение и дисперсия |
| `mad()` | Среднее абсолютное отклонение |
| `prod()` | Произведение всех элементов |
| `sum()` | Сумма всех элементов |

Это все методы объектов `DataFrame` и `Series`.


Однако для более глубокого изучения данных простых сводных показателей часто недостаточно.
Следующим уровнем обобщения данных является операция `groupby`, которая позволяет быстро и эффективно вычислять сводные показатели по подмножествам данных.


## GroupBy: разделить, применить, объединить

Простые агрегирующий функции могут дать  представление о даборе данных в целом, но часто требуется выполнить условное агрегирование по некоторой метке или индексу: это реализовано в операции `groupby`.
Название &laquo;group by&raquo; (&laquo;группировать по&raquo; происходит от команды языка баз данных SQL. Но, возможно, более понятно будет рассматривать его в терминах, впервые введенных Хэдли Уикхэмом, известным специалистом по R: *разделить, применить, объединить*.


### Разделить, применить, объединить

Канонический пример этой операции &laquo;разделить-применить-объединить&raqui;, где &laquo;применить&raquo; &mdadh; это суммирование, показан на следующем рисунке:


![](./img/split-apply-combine.png)


Рисунок ясно показывает, что делает `groupby`:

- Шаг *разделения* включает в себя разделение на части и группировку `DataFrame` в зависимости от значения указанного ключа.
- Шаг *применить* включает вычисление некоторой функции, обычно агрегирующей, преобразование или фильтрацию, в пределах отдельных подмножеств данных.
- Шаг *объединения* выполняет слияние результатов этих операций в результирующий массив.


Хотя, конечно, можно было бы сделать все это вручную с помощью какого-либо сочетания описанных выше команд маскирования, агрегирования и слияния, важно понимать, что не обязательно создавать объекты для промежуточных разбиений.
Операция GroupBy может проделать все это за один проход по данным, вычисляя сумму, среднее значение, количество, минимум и другие сводные показатели для каждой группы.

Мощь операции GroupBy состоит в абстрагировании этих шагов: пользователю не нужно заботиться о том, как фактически выполняются вычисления, а можно вместо этого думать об операции в целом.


В качестве конкретного примера давайте рассмотрим использование Pandas для вычислений, показанных на этой диаграмме.
Начнем с создания входного ``DataFrame``:

```python jupyter={"outputs_hidden": false}
df = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],
                   'data': range(6)}, columns=['key', 'data'])
df
```

Самую простую операцию &laquo;разделить-применить-объединить&raquo; можно вычислить с помощью метода `groupby()` класса `DataFrame`, передав имя нужного ключевого столбца:

```python jupyter={"outputs_hidden": false}
df.groupby('key')
```

Обратите внимание, что возвращается не набор `DataFrame`, а объект `DataFrameGroupBy`.
В этом объекте и заключается вся магия: можно думать о нем как о специальном представлении `DataFrame`, которое готово анализировать группы, но не выполняет никаких фактических вычислений, пока не будет применено агрегирование.
Такой подход &laquo;отложенных вычислений&raquo;  означает возможность очень эффективной реализации распространенных агрегирующих функций, причем практически прозрачным для пользователя образом.

Чтобы получить результат, нужно применить один из аггрегирующих методов к объекту `DataFrameGroupBy`, который и выполнит соответствующие шаги применения/объединения для получения желаемого результата:

```python jupyter={"outputs_hidden": false}
df.groupby('key').sum()
```

Метод `sum()` &mdash; это всего лишь одна из возможностей.
К объекту `DataFrameGroupBy` можно применить практически любую функцию агрегирования Pandas или NumPy, а также практически любую допустимую операцию `DataFrame`.


### Объект GroupBy

Объект `GroupBy` представляет собой очень гибкую абстракцию.
Во многих отношениях его можно рассматривать просто как коллекцию объектов `DataFrame`, и он делает сложные вещи под капотом. 
Давайте рассмотрим несколько примеров с использованием данных Planets.

Возможно, наиболее важными операциями, доступными с помощью ``GroupBy``, являются *агрегированияе, *фильтрация*, *преобразование* и *применение*.
Рассмотрим их подробнее чуть позже, а пока познакомимся с другой функциональностью, которую можно использовать с базовой операцией `GroupBy`.


#### Индексация по столбцам

Объект `GroupBy` поддерживает индексацию столбцов так же, как `DataFrame`, возвращая при этом измененный объект `GroupBy``.
Например:

```python jupyter={"outputs_hidden": false}
planets.groupby('method')
```

```python jupyter={"outputs_hidden": false}
planets.groupby('method')['orbital_period']
```

В примере была выбрана конкретнуая группа `Series` из исходной группы `DataFrame` по имени ее столбца.
Как и в случае с объектом `GroupBy`, никаких вычислений не выполняется, пока не будет вызван какой-либо агрегирующий метод:

```python jupyter={"outputs_hidden": false}
planets.groupby('method')['orbital_period'].median()
```

Результат позволяет получить общее представление о масштабе чувствительности каждого из методов к периодам обращения (в днях). 


#### Итерация по группам

Объект `GroupBy` поддерживает прямую итерацию по группам, возвращая каждую группу как `Series` или `DataFrame`:

```python jupyter={"outputs_hidden": false}
for (method, group) in planets.groupby('method'):
    print(f'{method:30s} shape={group.shape}')
```

Это может пригодиться для выполнения ручного вычисления некоторых значений, хотя обычно быстрее воспользоваться встроенной функциональностью `apply`.


#### Методы диспетчеризации

Благодаря определенной магии классов Python любой метод, явно не реализованный объектом `GroupBy`, будет передан и вызван для групп, независимо от того, являются ли они объектами `DataFrame` или `Series`.
Например, можно воспользоваться методом `describe()` объекта `DataFrame` для выпчисления сводных показателей, описывающих каждую группу данных:

```python jupyter={"outputs_hidden": false}
planets.groupby('method')['year'].describe().unstack()
```

Рассмотрение этой таблицы помогает нам лучше понять данные: например, подавляющее большинство планет было открыто методами лучевой скорости и транзита, хотя последний стал распространенным (благодаря новым, более точным телескопам) только в последнее десятилетие.
Новейшими методами, по-видимому, являются методы изменения времени прохождения и модуляции орбитальной яркости, которые не применялись для открытия новых планет до 2011 года.

Это всего лишь один пример полезности методов диспетчеризации.
Обратите внимание, что они применяются *к каждой отдельной группе*, а затем результаты объединяются в `GroupBy` и возвращаются.
Опять же, любой допустимый метод объекта `DataFrame`/`Series` может быть использован для соответствующего объекта `GroupBy`, что позволяет выполнять некоторые очень гибкие и мощные операции!


### Агрегирование, фильтрация, преобразование, применение

Предыдущее обсуждение было сосредоточено на агрегировании применительно к операции объединения, но доступны и другие возможности.
В частности, объекты `GroupBy` имеют методы `aggregate()`, `filter()`, `transform()` и `apply()`, которые эффективно реализуют множество полезных операций перед объединением сгруппированных данных.

Для целей следующих подразделов мы будем использовать этот `DataFrame`:

```python jupyter={"outputs_hidden": false}
rng = np.random.RandomState(0)
df = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],
                   'data1': range(6),
                   'data2': rng.randint(0, 10, 6)},
                   columns = ['key', 'data1', 'data2'])
df
```

#### Агрегирование

Метод `aggregate()` обеспечивает еще большую гибкость по сравнению с другими методами агрегирования, такими как, `sum()` или `median()`.
Он принимает на вход строку, или список строк с именами агрегирующих функций и вычисляет все сводные показатели сразу. 

Вот краткий пример, как это может выглядеть:

```python jupyter={"outputs_hidden": false}
df.groupby('key').aggregate(['min', 'median', 'max'])
```

Еще один полезный прием &mdash; передача словаря, сопоставляющего имена столбцов с операциями, которые будут применены к этому столбцу:

```python jupyter={"outputs_hidden": false}
df.groupby('key').aggregate({'data1': 'min',
                             'data2': 'max'})
```

#### Фильтрация

Операция фильтрации позволяет отбрасывать данные в зависимости от свойств группы.
Например, можно оставить в результате только те группы, в которых стандартное отклонение больше некоторого критического значения:

```python jupyter={"outputs_hidden": false}
def filter_func(x):
    return x['data2'].std() > 4

Display('df', 'df.groupby("key").std()', 'df.groupby("key").filter(filter_func)')
```

Функция `filter()` должна возвращать логическое значение, указывающее, прошла ли группа фильтрацию. 
В данном примере, так как стандартное отклонение группы A не превышает 4, она исключается из результата.


#### Преобразование

В то время как агрегирующая функция должна возвращать сокращенную версию данных, преобразование может возвращать некоторую преобразованную версию полных данных для дальнейшей перекомпановки.
При таком преобразовании форма выходных данных совпадает с формой входных.
Типичным примером является центрирование данных путем вычитания среднего значения по группам:

```python jupyter={"outputs_hidden": false}
df.groupby('key').transform(lambda x: x - x.mean())
```

#### Применение

Метод `apply()` позволяет применить произвольную функцию к результатам группы.
Функция должна принимать `DataFrame` и возвращать либо объект Pandas (например, `DataFrame`, `Series`), либо скаляр. Операция объединения будет выбрана в зависимости от типа возвращаемых выходных данных.

Например, вот пример `apply()`, который нормализует первый столбец по сумме второго:

```python jupyter={"outputs_hidden": false}
def norm_by_data2(x):
    # x — объект DataFrame сгруппированных значений
    x['data1'] /= x['data2'].sum()
    return x

Display('df', 'df.groupby("key")[["data1", "data2"]].apply(norm_by_data2)')
```

`apply()` внутри `GroupBy` довольно гибок: единственным критерием является то, что функция принимает `DataFrame` и возвращает объект Pandas или скаляр.


### Указание ключа разбиения

В представленных ранее простых примерах `DataFrame` разбивался по одному столбцу.
Это всего лишь один из многих вариантов, с помощью которых можно определить группы.
Рассмотрим далее некоторые другие возможности.


#### Список, массив, объект Series и индекс как ключи группировки

Ключом может быть любая последовательность с длиной, соответствующей длине `DataFrame`. 
Например:

```python jupyter={"outputs_hidden": false}
L = [0, 1, 0, 1, 2, 0]
Display('df', 'df.groupby(L).sum()')
```

Разумеется, это значит, что есть еще один, несколько более длинный способ выполнить вышеприведенную операцию `df.groupby('key')`:

```python jupyter={"outputs_hidden": false}
Display('df', "df.groupby(df['key']).sum()")
```

#### Словарь или объект Series, связывающий индекс и группу

Другой метод — предоставить словарь, который сопоставляет значения индекса с ключами группировки:

```python jupyter={"outputs_hidden": false}
df2 = df.set_index('key')
mapping = {'A': 'vowel', 'B': 'consonant', 'C': 'consonant'}
Display('df2', 'df2.groupby(mapping).sum()')
```

#### Любая функция Python

Аналогично заданию соответствия можно передать функции `groupby` любую функцию Python, принимающую на входе значение индекса и возвращающую группу:

```python jupyter={"outputs_hidden": false}
Display('df2', 'df2.groupby(str.lower).mean()')
```

#### Список допустимых ключей

Можно комбинировать любые из предыдущих вариантов ключей для группировки по мультииндексу:

```python jupyter={"outputs_hidden": false}
df2.groupby([str.lower, mapping]).mean()
```

### Пример группировки

В качестве примера соберем все это вместе в нескольких строках кода на языке Python и подсчитаем количество открытых планет по методу открытия и десятилетию:

```python jupyter={"outputs_hidden": false}
decade = 10 * (planets['year'] // 10)
decade = decade.astype(str) + 's'
decade.name = 'decade'
planets.groupby(['method', decade])['number'].sum().unstack().fillna(0)
```

Это демонстрирует эффективность объединения многих операций, которые обсуждались до сих пор, при рассмотрении реалистичных наборов данных.
Вот так легко можно получить представление о том, когда и как были открыты планеты за последние несколько десятилетий!
Это, конечно, довольно сложный пример, но понимание этих фрагментов даст вам возможность аналогичным образом исследовать собственные данные.
