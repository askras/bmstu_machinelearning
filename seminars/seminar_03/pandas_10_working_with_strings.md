---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Векторизованные операции над строками


Одной из сильных сторон Python является относительная простота обработки и манипулирования строковыми данными.
Pandas дополнительно предоставляет набор *векторизованных строковых операций*, которые являются важной частью обработки (чаще всего очистки) данных, необходимой при работе с реальными данными.
Давайте познакомимся с некоторыми строковыми операциями Pandas.


## Знакомимся со строковыми операциями Pandas

Инструменты вроде NumPy и Pandas обобщают арифметические операции, чтобы можно было легко и быстро выполнять одну и ту же операцию над множеством элементами массива. Например:

```python jupyter={"outputs_hidden": false}
import numpy as np
x = np.array([2, 3, 5, 7, 11, 13])
x * 2
```

Такая *векторизация* операций упрощает синтаксис работы с массивами данных: пользователю больше не нужно беспокоиться о размере или форме массива, а только о том, какую операцию необходимо выполнить.
Библиотека NumPy не предоставляет такого простого способа доступа для массивов строк, так что приходится использовать более длинный синтаксис циклов:

```python jupyter={"outputs_hidden": false}
data = ['пётр', 'Иван', 'СЕРГЕЙ', 'мАРИЯ']
[s.capitalize() for s in data]
```

Возможно, этого достаточно для работы с небольшими и наборами данных, в которых к тому же нет пропусков. 
Но если будут пропущены какие-либо значения, то данный код перестанет работать:

```python
%%capture
data = ['пётр', 'Иван', None, 'СЕРГЕЙ', 'мАРИЯ']
[s.capitalize() for s in data]
```

Поэтому такой подход требует дополнительных проверок:

```python jupyter={"outputs_hidden": false}
data = ['пётр', 'Иван', None, 'СЕРГЕЙ', 'мАРИЯ']
[s if s is None else s.capitalize() for s in data]
```

Такой ручной подход многословен и неудобен, что повышает вероятность появления ошибок.

Библиотека Pandas включает средства как для работы с векторизованными строковыми операциями, так и для корректной обработки отсутствующих значений посредством атрибута `str` объектов Series библиотеки Pandas и содержащих строки объектов Index. 

Например имеется объект Series с теми же данными::

```python jupyter={"outputs_hidden": false}
import pandas as pd
names = pd.Series(data)
names
```


Теперь можно вызвать один единственный метод для преобразования строчных
букв в заглавные, который будет игнорировать любые отсутствующие значения:

```python jupyter={"outputs_hidden": false}
names.str.capitalize()
```


## Таблицы методов Pandas для работы со строками

Большая часть синтаксиса Pandas для работы со строками достаточно интуитивна и похожа на соответсвтующие методы Python.

В примерах будет использоваться следующий объект `Series`:

```python
authors = pd.Series(['Александр Сергеевич Пушкин', 
                     'Михаил Юрьевич Лермонтов', 
                     'Лев Николаевич Толстой',
                     'Антон Павлович Чехов', 
                     'Федор Михайлович Достоевский', 
                     'Николай Василльевич Гоголь',])
```

### Методы, аналогичные методам работы со строками Python

Практически для всех встроенных строковых методов Python есть соответствующий векторизованный строковый метод библиотеки Pandas. 
Вот список методов атрибута `str` библиотеки Pandas, дублирующий строковые методы языка Python:

|           |                |                |                |
|-----------|----------------|----------------|----------------|
|`len()`    | `lower()`      | `translate()`  | `islower()`    |
|`ljust()`  | `верхний()`    | `startswith()` | `isupper()`    |
|`rjust()`  | `find()`       | `endswith()`   | `isnumeric()`  |
|`center()` | `rfind()`      | `isalnum()`    | `isdecimal()`  |
|`zfill()`  | `index()`      | `isalpha()`    | `split()`      |
|`strip()`  | `rindex()`     | `isdigit()`    | `rsplit()`     |
|`rstrip()` | `capitalize()` | `isspace()`    | `partition()`  |
|`lstrip()` | `swapcase()`   | `istitle()`    | `rpartition()` |

Обратите внимание, что возвращаемые значения у них отличаются. 
Так, например `lower()`, возвращают `Series` строк:

```python jupyter={"outputs_hidden": false}
authors.str.lower()
```

Часть методов возвращает числовые значения:

```python jupyter={"outputs_hidden": false}
authors.str.len()
```

А некоторые возвращают логические значения:

```python jupyter={"outputs_hidden": false}
authors.str.startswith('А')
```

Другие возвращают списки или другие составные значения для каждого элемента:

```python jupyter={"outputs_hidden": false}
authors.str.split()
```

### Методы, использующие регулярные выражения

Кроме того, существует несколько методов, которые принимают регулярные выражения (regexps) для проверки содержимого каждого элемента строки.
В основном они все следуют соглашениям API встроенного модуля `re` Python:

| Метод | Описание |
|-----------|-------------|
| `match`   | Вызывает `re.match` для каждого элемента, возвращая логическое значение. |
| `extract` | Вызывает `re.match` для каждого элемента, возвращая сопоставленные группы в виде строк.|
| `findall` | Вызывает `re.findall` для каждого элемента |
| `replace` | Заменяет вхождения шаблона на некоторую другую строку|
| `contains`| Вызывает `re.search` для каждого элемента, возвращая логическое значение |
| `count`   | Подсчитывает количество вхождений шаблона|
| `split`   | Эквивалентно `str.split`, но принимает регулярные выражения |
| `rsplit`  | Эквивалентно `str.rsplit`, но принимает регулярные выражения |


С помощью этих функций можно выполнять широкий спектр операций.
Например, извлечь имена из каждого элемента, запросив непрерывную группу символов в начале каждого элемента:

```python jupyter={"outputs_hidden": false}
authors.str.extract('([А-Яа-я]+)', expand=False)
```

Можно сделать еще что-то более сложное, например, найти все имена, которые начинаются и заканчиваются на согласную, используя символы начала строки (`^`) и конца строки (`$`) регулярного выражения:

```python
'АЕЁИОУЫЭЮЯ'.capitalize()
```

```python jupyter={"outputs_hidden": false}
authors.str.findall(r'^[^АЕЁИОУЫЭЮЯ].*[^аеёиоуыэюя]$')
```

Такой лаконичный синтаксис регулярных выражений для элеменов `Series` или `DataFrame` открывает множество возможностей для анализа и очистки данных.


### Прочие методы

Наконец, есть несколько дополнительных методов, которые позволяют выполнять ряд других полезных операции:

| Метод           | Описание |
|-----------------|-------------|
| `get`           | Индексирует каждый элемент |
| `slice`         | Разрезает каждый элемент|
| `slice_replace` | Заменяет срез в каждом элементе переданным значением|
| `cat`           | Объединяет строки|
| `repeat`        | Повторяет значения |
| `normalize`     | Возвращает строки в формате Unicode |
| `pad`           | Добавляет пробелы слева, справа или с обеих сторон строки|
| `wrap`          | Разбивает длинные строки на строки длиной меньше заданной ширины|
| `join`          | Объединяет строки в каждом элементе `Series` с переданным разделителем|
| `get_dummies`   | Извлекает фиктивные переменные как `DataFrame` |


#### Векторизованный доступ к элементам и вырезание подстрок

В частности, операции `get` и `slice` обеспечивают векторизованный доступ к элементам из каждого массива.
Например, можно получить срез первых трех символов каждого массива, используя `str.slice(0, 3)`.
Обратите внимание, что это поведение также доступно через обычный синтаксис индексации Python.
Например, `df.str.slice(0, 3)` эквивалентно `df.str[0:3]`:

```python jupyter={"outputs_hidden": false}
authors.str.slice(0, 3) == authors.str[0:3]
```

```python
authors.str.slice(0, 3)
```

Индексация через `df.str.get(i)` и `df.str[i]` также аналогична.

Эти методы индексации также позволяют получать доступ к элементам массивов, возвращаемых `split`.
Например, чтобы извлечь фамилию каждой записи, можно объединить индексацию `split` с `str`:

```python jupyter={"outputs_hidden": false}
authors.str.split().str[-1]
```

#### Индикаторные переменные

Еще один метод, требующий небольшого дополнительного объяснения, &mdash; это метод `get_dummies`.
Иногда полезно, иметь в данных столбец, содержащий какой-либо кодированный индикатор.
Например, может быть набор данных, содержащий информацию в виде кодов, например, `A = "поэт"`, `B = 'прозаик'`, `C = 'погиб на дуэле'`, `D = писал сказки`:

```python jupyter={"outputs_hidden": false}
full_authors = pd.DataFrame({'name': monte,
                           'info': ['А|B|C|D', 
                                    'А|B|C', 
                                    'B|D',
                                    'B', 
                                    'B', 
                                    'B']})
full_authors
```

Процедура `get_dummies` позволяет быстро разбить все индикаторные переменные, преобразовав их в объект `DataFrame`:

```python jupyter={"outputs_hidden": false}
full_authors['info'].str.get_dummies('|')
```

Используя эти операции в качестве строительных блоков, можно создать бесконечный спектр процедур обработки строк при очистке данных.

Дополнительную информацию можно получить онлайн-документации Pandas или обратиться к ресурсам, перечисленным в ["Working with Text Data"](https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html).
