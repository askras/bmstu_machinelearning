---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Знакомство с объектами Pandas


Упрощенно объекты Pandas можно рассматривать как улучшенные версии структурированных массивов NumPy, в которых строки и столбцы идентифицируются метками, а не простыми целочисленными индексами.
Pandas предоставляет множество полезных инструментов, методов и функций в дополнение к базовым структурам данных. Но для того чтобы начать эффективо с ними работать, необходимо понять как они устроены изнутри.
Прежде чем двигаться дальше, познакомимся с тремя основными структурами данных Pandas: классами `Series`, `DataFrame` и `Index`.

Прежде всего импортируем необходимые пакеты:

```python
import numpy as np
import pandas as pd
```

## Объект Series

Объект `Series` библиотеки Pandas &mdash; это одномерный массив индексированных данных.
Его можно создать из списка или массива:

```python jupyter={"outputs_hidden": false}
data = pd.Series([0.25, 0.5, 0.75, 1.0])
data
```

Как можно видеть, `Series` помимо последовательности самих значений, содержит также и последовательность индексов. Получить доступ к элементам Series можно используя его атрибут  `values`: 

```python jupyter={"outputs_hidden": false}
data.values
```

`values` &mdash; это всего лишь массив NumPy:


Для доспупа к индексам Объекта Series предназначен его атрибут `index`:

```python jupyter={"outputs_hidden": false}
data.index
```

`index` представляет собой, похожий на массив, объект `pd.Index` (или производный от него), который рассмотрим подробнее чуть позже.


Как и в случае с массивом NumPy, доступ к данным можно получить по соответствующему индексу с помощью привычной записи Python в квадратных скобках:

```python jupyter={"outputs_hidden": false}
data[1]
```

```python jupyter={"outputs_hidden": false}
data[1:3]
```

Однако, `Series` гораздо более универсален и гибок, чем лежащий в его основе одномерный массив NumPy.


### Объект `Series` как обобщенный массив NumPy


Приведенные примеры могут ввести в заблуждение, будто бы объект `Series` по сути взаимозаменяем с одномерным массивом NumPy.
Но это не так!
Существенным отличием является наличие индекса.
В то время как массив Numpy имеет *неявно определенный* целочисленный индекс, используемый для доступа к значениям, `Series` имеет *явно определенный* индекс, связанный со значениями.

Это явное определение индекса дает объекту `Series` дополнительные возможности. Например, индекс не обязательно должен быть целым числом, он может состоять из значений любого желаемого типа.
Например, при желании в качестве индекса можно использовать, например, строки:

```python jupyter={"outputs_hidden": false}
data = pd.Series([0.25, 0.5, 0.75, 1.0],
                 index=['a', 'b', 'c', 'd'])
data
```

При этом доступ к элементам работает привычным образом:

```python jupyter={"outputs_hidden": false}
data['b']
```

Можно использовать даже несмежные или непоследовательные индексы:

```python jupyter={"outputs_hidden": false}
data = pd.Series([0.25, 0.5, 0.75, 1.0],
                 index=[2, 5, 3, 7])
data
```

```python jupyter={"outputs_hidden": false}
data[5]
```

Таким образом, обхъект `Series` Pandas можно рассматривать как специализированную разновидность специализацию словаря Python.


### Объект Series как специализированный словарь

Словарь &mdash; это структура, которая сопоставляет произвольные ключи с набором произвольных значений, а объект `Series` &mdash; это структура, которая сопоставляет типизированные ключи с набором типизированных значений.
Такая типизация очень важна: так же, как соответствующий типу специализированный код для массива библиотеки NumPy при выполнении определенных операций делает его эффективнее, чем стандартный список Python, информация о типе в объекте Series библиотеки Pandas делает его намного более эффективным для определенных операций, чем словари Python.

Аналогию `Series` &mdash; как словаря можно сделать еще более наглядной, создав объект `Series` непосредственно из словаря Python:

```python jupyter={"outputs_hidden": false}
population_dict = {'Москва': 13149803,
                   'Санкт-Петербург': 5597763,
                   'Новосибирск': 1633851,
                   'Екатеринбург': 1536183,
                   'Казань': 1318604,
                   'Красноярск': 1205473,}

population = pd.Series(population_dict)
population
```

По умолчанию при этом будет создан объект Series с полученным из ключей индексом. 
Следовательно, получить доступ к элементам, можно как к элементам обычного словаря:

```python jupyter={"outputs_hidden": false}
population['Новосибирск']
```

Однако, в отличие от словаря, `Series` также поддерживает операции характерные для массивов, такие как срезы:

```python jupyter={"outputs_hidden": false}
population['Санкт-Петербург':'Казань']
```

Некоторые особенности индексации и срезов Pandas будут подробнее рассмотрены в [Индексация и выборка данных](pandas_02_data_indexing_and_selection.md).

<!-- #region -->
### Создание объектов `Series`

Рассмотренные методы создания `Series` с нуля представляют собой по сути вариации следующего кода:

```python
>>> pd.Series(data, index=index)
```

где `index` &mdash; необязательный аргумент, а `data` может быть одним из итерируемых объектов Python.

Если, например, `data` является списком или массивом NumPy, то `index` по умолчанию представляет собой целочисленную последовательность:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
pd.Series([2, 4, 6])
```

`data` может быть скаляром, который, при необходимости, будет повторяться для заполнения указанного индекса:

```python jupyter={"outputs_hidden": false}
pd.Series(5, index=[100, 200, 300])
```

`data` может быть словарем, в котором `index` по умолчанию соответствует отсортированным ключам словаря:

```python jupyter={"outputs_hidden": false}
pd.Series({2:'a', 1:'b', 3:'c'})
```

Однако, при необходимости, в каждом из этих случаев индекс может быть задан явно:

```python jupyter={"outputs_hidden": false}
pd.Series({2:'a', 1:'b', 3:'c'}, index=[3, 2, 5])
```

Обратите внимание, что в последнем случае `Series` заполняется только явно указанными ключами. Значения для отсутствующих в словаре ключей помечается как неопределенное.


## Объект DataFrame

Следующая фундаментальная структура в Pandas &mdash; это `DataFrame`.
Как и `Series`, объект `DataFrame` можно рассматривать либо как обобщение массива NumPy, либо как специализацию словаря Python.
Рассмотрим каждую из этих точек зрения.


### DataFrame как обобщенный массив NumPy
Если `Series` является аналогом одномерного массива с гибкой индексацией, то `DataFrame` можно рассматривать как аналог двумерного массива как с гибкими индексами строк, так и с гибкими именами столбцов.
Так же, как двумерный массив можно представить как упорядоченную последовательность выровненных одномерных столбцов, так и `DataFrame` можно представить как упорядоченную последовательность выровненных объектов `Series`.
Здесь под &laquo;выровненными&raquo; мы подразумеваем, что они имеют один и тот же индекс.

Чтобы продемонстрировать это, давайте сначала создадим объект `Series`, в котором будут перечислены площади каждого из щести рассмотренных выше городов:

```python jupyter={"outputs_hidden": false}
area_dict = {'Москва': 2561.5,
             'Санкт-Петербург': 1439.0,
             'Новосибирск': 502.7,
             'Екатеринбург': 1110.7,
             'Казань': 638.4,
             'Красноярск': 413.0,}

area = pd.Series(area_dict)
area
```

Воспользовавшись объектом `population` класса `Series`, сконструируем на основе
словаря единый двумерный объект, содержащий всю эту информацию:

```python jupyter={"outputs_hidden": false}
cities = pd.DataFrame({'population': population,
                       'area': area})
cities
```

Как и объект `Series`, `DataFrame` имеет атрибут `index`, который предоставляет доступ к меткам индекса:

```python jupyter={"outputs_hidden": false}
cities.index
```

Кроме того, `DataFrame` имеет атрибут `columns`, который представляет собой объект `Index`, содержащий метки столбцов:

```python jupyter={"outputs_hidden": false}
cities.columns
```

Таким образом, `DataFrame` можно рассматривать как обобщение двумерного массива NumPy, где как у строк, так и у столбцов есть обобщенные индексы для доступа к данным.


### DataFrame как специализированный словарь

Аналогично можно рассматривать `DataFrame` как специализацию словаря.
В то время как словарь сопоставляет ключ со значением, `DataFrame` сопоставляет имя столбца с `Series` данных столбца.
Например, запрос атрибута `area` возвращает объект `Series`, содержащий площади городов:

```python jupyter={"outputs_hidden": false}
cities['area']
```

Обратите внимание на потенциальный источник путаницы: в двумерном массиве NumPy `data[0]` вернет первую *строку*. 
Для `DataFrame`, `data['col0']` вернет первый *столбец*.
По этой причине, вероятно, лучше рассматривать `DataFrame` как обобщение словаря, а не как обобщение массива, хотя оба способа рассмотрения ситуации могут быть полезны.

Более гибкие способы индексации `DataFrame` рассмотрены в [Индексация и выборка данных](pandas_02_data_indexing_and_selection.md).


### Создание объектов DataFrame

`DataFrame` в Pandas можно создать разными способами.
Приведем несколько примеров.


#### Из одного объекта Series

`DataFrame` представляет собой коллекцию объектов `Series`, а `DataFrame` с одним столбцом может быть создан из одного `Series`:

```python jupyter={"outputs_hidden": false}
pd.DataFrame(population, columns=['population'])
```

#### Из списка словарей

Любой список словарей можно преобразовать в `DataFrame`.
Воспользуемся включением в список для создания набора данных:

```python jupyter={"outputs_hidden": false}
data = [{'a': i, 'b': 2 * i} for i in range(3)]
pd.DataFrame(data)
```

Даже если некоторые ключи в словаре отсутствуют, Pandas заполнит их значениями ``NaN`` (т. е. &laquo;не число&raquo;):

```python jupyter={"outputs_hidden": false}
pd.DataFrame([{'a': 1, 'b': 2}, {'b': 3, 'c': 4}])
```

#### Из словаря объектов Series

Аналогично `DataFrame` может быть создан из словаря объектов `Series`:

```python jupyter={"outputs_hidden": false}
pd.DataFrame({'population': population,
              'area': area})
```

#### Из двумерного массива NumPy

Имея двумерный массив данных, можно создать `DataFrame` с любыми указанными именами столбцов и индексов:

```python jupyter={"outputs_hidden": false}
pd.DataFrame(np.random.rand(3, 2),
             columns=['foo', 'bar'],
             index=['a', 'b', 'c'])
```

Если этот опуcтить параметры `columns` и/или `index`, для каждого параметра будет использоваться целочисленный индекс:

```python
pd.DataFrame(np.random.rand(3, 2))
```

#### Из структурированного массива NumPy

`DataFrame` библиотеки Pandas работает во многом как структурированный массив и может быть создан непосредственно из него:

```python jupyter={"outputs_hidden": false}
A = np.zeros(3, dtype=[('A', 'i8'), ('B', 'f8')])
A
```

```python jupyter={"outputs_hidden": false}
pd.DataFrame(A)
```

## Объект Index библиотеки Pandas

Объекты `Series` и `DataFrame` содержат явный *индекс*, который позволяет ссылаться на данные и изменять их.
Этот объект `Index` сам по себе является интересной структурой, и его можно рассматривать либо как *неизменяемый массив* (*immutable array*), либо как *упорядоченный набор* (*ordered set*) (технически мультимножество, поскольку объекты `Index` могут содержать повторяющиеся значения).
Эти способы представления имеют некоторые интересные последствия для операций, доступных над объектами `Index`.
В качестве простого примера давайте создадим `Index` из списка целых чисел:

```python jupyter={"outputs_hidden": false}
ind = pd.Index([2, 3, 5, 7, 11])
ind
```

### Индекс как неизменяемый массив

`Index` во многих отношениях работает как массив.
Например, можем использовать стандартную нотацию индексации Python для извлечения значений или срезов:

```python jupyter={"outputs_hidden": false}
ind[1]
```

```python jupyter={"outputs_hidden": false}
ind[::2]
```

Объекты `Index` также имеют многие атрибуты, имеющиеся у массивов NumPy:

```python jupyter={"outputs_hidden": false}
print(ind.size, ind.shape, ind.ndim, ind.dtype)
```

Существенное различие между объектами `Index` и массивами NumPy заключается в том, что индексы являются неизменяемыми, то есть их нельзя изменять обычными способами:

```python jupyter={"outputs_hidden": false}
%%capture

ind[1] = 0
```

Эта неизменность делает более безопасным совместное использование индексов несколькими `DataFrame` и массивами, исключая потенциальные побочные эффекты от непреднамеренного изменения индекса.


### Индекс как упорядоченный набор

Объекты библиотеки Pandas спроектированы с целью упрощения таких операций, как соединения наборов данных, построенное на операциях арифметики множеств.
Объект `Index` следует многим соглашениям, используемым встроенной структурой данных `set` в Python, так что объединения, пересечения, разности и другие комбинации можно вычислять знакомым способом:

```python jupyter={"outputs_hidden": false}
indA = pd.Index([1, 3, 5, 7, 9])
indB = pd.Index([2, 3, 5, 7, 11])
```

```python jupyter={"outputs_hidden": false}
indA & indB  # пересечение
```

```python jupyter={"outputs_hidden": false}
indA | indB  #  объединение
```

```python jupyter={"outputs_hidden": false}
indA ^ indB  # симметричная разность
```

К этим операциям также можно получить доступ через методы объекта, например:

```python
indA.intersection(indB)
```
