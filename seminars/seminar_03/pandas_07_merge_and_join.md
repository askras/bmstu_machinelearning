---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Объединение наборов данных: функция `pd.merge` и метод `pd.DataFrame.join`


Одним из важнейших свойств Pandas являются высокопроизводительные, выполняемые в оперативной памяти операции объединения `merge` и `join`.
Те, кто работал с базами данных, должны быть знакомы с этим типом преобразования данных.

Функция `merge()` позволяет объединить датафреймы по общим столбцам. 
Метод `join()` позволяет объединить датафреймы по индексам. 

```python
import pandas as pd
import numpy as np
```

Для удобства начнем с переопределения функциональности `display()` из предыдущего раздела:

```python
class Display:
    '''Создает HTML-представление нескольких объектов'''
    template = """<div style="float: left; padding: 10px;">
    <p style='font-family:"Courier New", Courier, monospace'>{0}</p>{1}
    </div>"""
    def __init__(self, *args):
        self.args = args
        
    def _repr_html_(self):
        return '\n'.join(self.template.format(a, eval(a)._repr_html_()) for a in self.args)
    
    def __repr__(self):
        return '\n\n'.join(a + '\n' + repr(eval(a)) for a in self.args)
```

## Реляционная алгебра

Поведение, реализованное в `pd.merge()`, является подмножеством того, что известно как *реляционная алгебра*, которая представляет собой формальный набор правил для манипулирования реляционными данными и формирует теоретическую основу операций, доступных в большинстве баз данных.
Преимущество подхода реляционной алгебры в том, что он предлагает несколько простейших операций, которые становятся строительными блоками более сложных операций над любым набором данных.
Благодаря эффективной реализованного в базе данных или другой программе подобного базового набора операций можно выполнять широкий диапазон весьма сложных составных операций.

Pandas реализует несколько из этих фундаментальных &laquo;кирпичиков&raquo; в функции `pd.merge()` и связанном с ней методе `join()` для `Series` и `Dataframe`.
Они позволяют эффективно связывать данные из разных источников.


## Виды соединений

Функция `pd.merge()` реализует несколько видов соединений: соединения &laquo;один-к-одному&raquo;, &laquo;многие-к-одному&raquo; и &laquo;многие-ко-многим&raquo;.
Доступ ко всем трем видам объединений осуществляется посредством вызова `pd.merge()`. 
Вид используемого соединения зависит от формы входных данных.
Рассмотрим простые примеры всех трех видов соединений и подробно обсудим их.


### Соединения один к одному

Возможно, самым простым видом соединения является соединение &laquo;один к одному&raquo;, которое во многом очень похоже на конкатенацию по столбцам, описанную в [Объединение наборов данных: функция `pd.concat` и метод `pd.DataFrame.append`](./pandas_06_concat_and_append.md).
В качестве конкретного примера рассмотрим следующие два `DataFrames`, которые содержат информацию о нескольких сотрудниках компании:

```python jupyter={"outputs_hidden": false}
df1 = pd.DataFrame({'employee': ['Борис', 'Иван', 'Наталья', 'Светлана'],
                    'group': ['Бухгалтерия', 'Лаборатория', 'Лаборатория', 'Склад']})
df2 = pd.DataFrame({'employee': ['Наталья', 'Борис', 'Иван', 'Светлана'],
                    'hire_date': [2009, 2018, 2017, 2022]})
Display('df1', 'df2')
```

Чтобы объединить эту информацию в один `DataFrame`, мы можем использовать функцию `pd.merge()`:

```python jupyter={"outputs_hidden": false}
df3 = pd.merge(df1, df2)
df3
```

Функция `pd.merge()` распознает, что каждый `DataFrame` имеет столбец &laquo;employee&raquo;, и автоматически выполняет соединение, используя этот столбец в качестве ключа.
Результатом слияния является новый `DataFrame`, который объединяет информацию из двух входных устройств.
Обратите внимание, что порядок записей в каждом столбце не обязательно должен быть одинаков.
В рассматриваемом примере порядок в столбце &laquo;employee&raquo; различается между `df1` и `df2`, и функция `pd.merge()` правильно обрабатывает эту ситуацию.
Кроме того, имейте в виду, что соединение в общем случае отбрасывает индекс, за исключением особого случая соединения по индексу (см. ключевые слова `left_index` и `right_index`, которые будут рассмотрены ниже).


### Соединения &laquo;многие к одному&raquo;


Соединения &laquo;многие к одному&raquo; &mdash; это соединения, в которых один из двух ключевых столбцов содержит повторяющиеся записи.
В этом случае результирующий `DataFrame` сохранит эти дублирующиеся записи соответствующим образом.
Рассмотрим следующий пример соединения:

```python jupyter={"outputs_hidden": false}
df4 = pd.DataFrame({'group': ['Бухгалтерия', 'Лаборатория', 'Склад'],
                    'supervisor': ['Николай', 'Геннадий', 'Семен']})
Display('df3', 'df4', 'pd.merge(df3, df4)')
```

Полученный `DataFrame` имеет дополнительный столбец с информацией о руководителе (supervisor) с повторением информации в одном или нескольких местах в соответствии с вводимыми данными.


### Соединения &laquo;многие ко многим&rquo;


Соединения &laquo;многие ко многим&rquo; более сложны.
Если ключевой столбец как в левом, так и в правом массиве содержит дубликаты, то результатом будет слияние &laquo;многие ко многим&rquo;
Пожалуй, наиболее наглядно это будет видно на конкретном примере.
Рассмотрим следующий пример: у нас есть `DataFrame`, показывающий один или несколько навыков, связанных с определенным отделом.
Выполняя соединение &laquo;многие ко многим&rquo;, можно восстановить навыки, связанные с любым отдельным человеком:

```python jupyter={"outputs_hidden": false}
df5 = pd.DataFrame({'group': ['Бухгалтерия', 'Бухгалтерия',
                              'Лаборатория', 'Лаборатория', 'Склад', 'Склад'],
                    'skills': ['Бухгалтерский учет', 'Финансы', 'Программирование', 'Математика',
                               'Логистика', 'Аудит']})
Display('df1', 'df5', "pd.merge(df1, df5)")
```

Все три вида соединений можно использовать совместно с другими инструментами Pandas для реализации широкого спектра функциональных возможностей.
Однако на практике наборы данных редко бывают такими чистыми, как приведенный здесь в качестве примера.
Рассмотрим некоторые параметры, предоставляемые `pd.merge()`, которые позволяют настраивать работу операции соединения.


## Задание ключа соединения


`pd.merge()` по умолчанию ищет одно или несколько совпадающих имен столбцов во входных объектах и использует их в качестве ключа.
Однако часто имена столбцов не совпадают дословно, поэтому `pd.merge()` предоставляет множество вариантов для решения этой проблемы.


### Параметры `on`

Например, можно явно задать имя ключевого столбца с помощью аргумента `on`, которое принимает имя столбца или список имен столбцов:

```python jupyter={"outputs_hidden": false}
Display('df1', 'df2', "pd.merge(df1, df2, on='employee')")
```

Этот приет сработает только в том случае, если и левый, и правый `DataFrame` имеют именованные столбцы.


### Параметры `left_on` и `right_on`

Иногда может потребоваться объединить два набора данных с разными именами столбцов.
Например, может быть набор данных, в котором имя сотрудника обозначено как  &laquo;Name&raquo;, а не &laquo;Employee&raquo;.
В этом случае можно использовать ключевые слова `left_on` и `right_on`, чтобы указать два имени столбцов:

```python jupyter={"outputs_hidden": false}
df3 = pd.DataFrame({'name': ['Борис', 'Иван', 'Наталья', 'Светлана'],
                    'salary': [70000, 80000, 120000, 90000]})
Display('df1', 'df3', 'pd.merge(df1, df3, left_on="employee", right_on="name")')
```

Результат содержит лишний столбец, который при желании можно удалить, например, с помощью метода `drop()` объекта `DataFrame`:

```python jupyter={"outputs_hidden": false}
pd.merge(df1, df3, left_on="employee", right_on="name").drop('name', axis=1)
```

### Параметры `left_index` и `right_index`

Иногда вместо объединения по столбцу требуется выполнить объединение по индексу.
Пусть, например, данные выглядят следующим образом:

```python jupyter={"outputs_hidden": false}
df1a = df1.set_index('employee')
df2a = df2.set_index('employee')
Display('df1a', 'df2a')
```

Вы можете использовать индекс в качестве ключа для слияния, задав параметры `left_index` и/или `right_index` в `pd.merge()`:

```python jupyter={"outputs_hidden": false}
Display('df1a', 'df2a',
        "pd.merge(df1a, df2a, left_index=True, right_index=True)")
```

Для удобства в `DataFrame` реализован метод `join()`, который выполняет соединение, по умолчанию выполняющееся по индексам:

```python jupyter={"outputs_hidden": false}
Display('df1a', 'df2a', 'df1a.join(df2a)')
```

При необходимости смешать индексы и столбцы, можно совместно использовать `left_index` с `right_on` или `left_on` с `right_index`:

```python jupyter={"outputs_hidden": false}
Display('df1a', 'df3', "pd.merge(df1a, df3, left_index=True, right_on='name')")
```

Все эти параметры также работают и в случае с несколькими индексами и/или несколькими столбцами.
Интерфейс этого варианта использования интуитивно понятен.
Более подробную информацию по данному вопросу смотрите в разделе [Merge, join, concatenate and compare](http://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html) документации Pandas.


## Задание операций над множествами для соединений


Во всех предыдущих примерах был проигнорирован один важный нюанс выполнения
соединения &mdash; вид используемой при соединении операции алгебры множестводно важное соображение при выполнении соединения.
А данный случай может играть важную роль в случаях, когда какое-либо значение есть в одном ключевом столбце, но отсутствует в другом. 
Рассмотрим пример:

```python jupyter={"outputs_hidden": false}
df6 = pd.DataFrame({'name': ['Петр', 'Павел', 'Мария'],
                    'food': ['Пончик', 'Пирожок', 'Печенье']},
                   columns=['name', 'food'])
df7 = pd.DataFrame({'name': ['Мария', 'Евгений'],
                    'drink': ['Сок', 'Лимонад']},
                   columns=['name', 'drink'])
Display('df6', 'df7', 'pd.merge(df6, df7)')
```

По умолчанию результат содержит *пересечение* двух наборов входных данных, так называемое*внутреннее соединениее* (*inner join*).

Можно указать это явным образом, с помощью параметра `how`, имеющего по умолчанию значение `'inner'`:

```python jupyter={"outputs_hidden": false}
pd.merge(df6, df7, how='inner')
```

Другими возможными значениями `how` являются `'outer'`, `'left'` и `'right'`.
*Внешнее соединение*  (*outer join*) возвращает соединение по объединению входных столбцов и заполняет все пропущенные значения NA:

```python jupyter={"outputs_hidden": false}
Display('df6', 'df7', "pd.merge(df6, df7, how='outer')")
```

*Левое соединение* (*left join*) и *правое соединение* (*right join*) возвращают соединения по левым и правым записям соответственно.
Например:

```python jupyter={"outputs_hidden": false}
Display('df6', 'df7', "pd.merge(df6, df7, how='left')")
```

Строки результата теперь соответствуют записям в левом из входных объектов.


Использование `how='right'` работает аналогичным образом:

```python
Display('df6', 'df7', "pd.merge(df6, df7, how='right')")
```

Все эти параметры можно напрямую применить к любому из предыдущих типов соединений.


## Пересекающиеся названия столбцов:  параметр `suffixes`


Наконец, вы можете оказаться в ситуации, когда два ваших входных ``DataFrame`` будут иметь конфликтующие имена столбцов.
Рассмотрим такой пример:

```python jupyter={"outputs_hidden": false}
df8 = pd.DataFrame({'name': ['Борис', 'Иван', 'Наталья', 'Светлана'],
                    'rank': [1, 2, 3, 4]})
df9 = pd.DataFrame({'name': ['Борис', 'Иван', 'Наталья', 'Светлана'],
                    'rank': [3, 1, 4, 2]})
Display('df8', 'df9', 'pd.merge(df8, df9, on="name")')
```

Поскольку выходные данные будут содержать два конфликтующих имени столбцов, функция слияния автоматически добавила в названия суффиксы `_x` и `_y`, чтобы сделать выходные столбцы уникальными.
Если подобное поведение, принятое по умолчанию, нежелательно, можно задать собственные суффиксы с помощью параметра `suffixes`:

```python jupyter={"outputs_hidden": false}
Display('df8', 'df9', 'pd.merge(df8, df9, on="name", suffixes=["_L", "_R"])')
```

Эти суффиксы работают с любым видом соединения, в том числе и в случае нескольких пересекающихся по названию столбцов


Более подробную информацию можно найти в разделе [Merge, join, concatenate and compare](http://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html) документации Pandas.
