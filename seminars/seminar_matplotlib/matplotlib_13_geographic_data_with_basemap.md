---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Отображение географических данных с помощью Basemap


Одним из распространенных типов визуализации при анализе данных данных является визуализация географических данных.
Основным инструментом Matplotlib для этого типа визуализации является набор инструментов Basemap, который, как и некоторые другие инструменты Matplotlib, находится в пространстве имен `mpl_toolkits`.
По общему признанию, Basemap немного неудобен в использовании, и зачастую даже простые визуализации отрисовываются гораздо дольше, чем можно было бы ожидать.
Более современные решения, такие как библиотека Leaflet или API Google (Yandex) Maps, могут оказаться лучшим выбором.
Тем не менее, Basemap &mdash; полезный инструмент для пользователей Python, который стоит иметь в своем виртуальном арсенале.
В этом разделе рассмотрим несколько примеров визуализации карт, которые можно реализовать с помощью этого набора инструментов.

Добавим всего один новый импорт в стандартный шаблон:

```python

```

```python jupyter={"outputs_hidden": false}
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
import numpy as np

%matplotlib inline
plt.style.use('default')

```

После установки и импорта набора инструментов Basemap географические графики будут доступны всего в нескольких строках (для графиков ниже также требуется пакет ``PIL`` в Python 2 или пакет ``pillow`` в Python 3):

```python jupyter={"outputs_hidden": false}
plt.figure(figsize=(8, 8))
m = Basemap(projection='ortho', resolution=None, lat_0=50, lon_0=-100)
m.bluemarble(scale=0.5);
```

Значение аргументов ``Basemap`` будет обсуждено ниже.

Полезно то, что показанный здесь глобус — это не просто изображение; это полнофункциональная библиотека осей Matplotlib, которая понимает сферические координаты и позволяет нам легко наносить данные на карту!
Например, мы можем использовать другую проекцию карты, приблизиться к Северной Америке и обозначить местоположение Сиэтла.
В качестве фона карты мы будем использовать изображение Etopo (на котором показаны топографические особенности как на суше, так и под водой):

```python jupyter={"outputs_hidden": false}
fig = plt.figure(figsize=(8, 8))
m = Basemap(projection='lcc', resolution=None,
            width=8E6, height=8E6, 
            lat_0=45, lon_0=-100,)
m.etopo(scale=0.5, alpha=0.5)

# Карта (долгота, широта) в координатах (x, y) для построения графика
x, y = m(-122.3, 47.6)
plt.plot(x, y, 'ok', markersize=5)
plt.text(x, y, ' Seattle', fontsize=12);
```

Это даст вам краткое представление о том, какие географические визуализации возможны с помощью всего лишь нескольких строк кода Python.
Теперь мы более подробно обсудим возможности Basemap и приведем несколько примеров визуализации картографических данных.
Используя эти краткие примеры в качестве строительных блоков, вы сможете создать практически любую визуализацию карты, какую только пожелаете.


## Картографические проекции

Первое, что следует решить при использовании карт, — это какую проекцию использовать.
Вы, вероятно, знакомы с тем фактом, что невозможно спроецировать сферическую карту, например, карту Земли, на плоскую поверхность, не исказив ее каким-либо образом и не нарушив ее непрерывности.
Эти прогнозы разрабатывались на протяжении всей истории человечества, и существует множество вариантов!
В зависимости от предполагаемого использования картографической проекции существуют определенные характеристики карты (например, направление, площадь, расстояние, форма и другие факторы), которые полезно сохранять.

Пакет Basemap реализует несколько десятков таких проекций, все из которых обозначены коротким кодом формата.
Здесь мы кратко продемонстрируем некоторые наиболее распространённые из них.

Начнем с определения удобной процедуры рисования нашей карты мира вместе с линиями долготы и широты:

```python jupyter={"outputs_hidden": false}
from itertools import chain

def draw_map(m, scale=0.2):
    # нарисовать рельефно-теневое изображение
    m.shadedrelief(scale=scale)
    
    # широта и долгота возвращаются как словарь
    lats = m.drawparallels(np.linspace(-90, 90, 13))
    lons = m.drawmeridians(np.linspace(-180, 180, 13))

    # ключи содержат экземпляры plt.Line2D
    lat_lines = chain(*(tup[1][0] for tup in lats.items()))
    lon_lines = chain(*(tup[1][0] for tup in lons.items()))
    all_lines = chain(lat_lines, lon_lines)
    
    # пройдитесь по этим строкам и установите нужный стиль
    for line in all_lines:
        line.set(linestyle='-', alpha=0.3, color='w')
```

### Цилиндрические проекции

Простейшими картографическими проекциями являются цилиндрические проекции, в которых линии постоянной широты и долготы отображаются в виде горизонтальных и вертикальных линий соответственно.
Этот тип картирования достаточно хорошо отображает экваториальные регионы, но приводит к сильным искажениям вблизи полюсов.
Расстояние между линиями широты различается в разных цилиндрических проекциях, что приводит к разным свойствам сохранения и разным искажениям вблизи полюсов.
На следующем рисунке показан пример *равнопромежуточной цилиндрической проекции*, в которой выбрано масштабирование широты, сохраняющее расстояния вдоль меридианов.
Другими цилиндрическими проекциями являются проекция Меркатора (``projection='merc'``) и цилиндрическая равновеликая проекция (``projection='cea'``).

```python jupyter={"outputs_hidden": false}
fig = plt.figure(figsize=(8, 6), edgecolor='w')
m = Basemap(projection='cyl', resolution=None,
            llcrnrlat=-90, urcrnrlat=90,
            llcrnrlon=-180, urcrnrlon=180, )
draw_map(m)
```

Дополнительные аргументы Basemap для этого представления указывают широту (``lat``) и долготу (``lon``) нижнего левого угла (``llcrnr``) и верхнего правого угла (``urcrnr``) желаемой карты в градусах.


### Псевдоцилиндрические проекции

Псевдоцилиндрические проекции смягчают требование, чтобы меридианы (линии постоянной долготы) оставались вертикальными; это может обеспечить лучшие свойства вблизи полюсов проекции.
Одним из распространенных примеров является проекция Мольвейде (``projection='moll'``), в которой все меридианы представляют собой эллиптические дуги.
Она построена таким образом, чтобы сохранить площадь всей карты: хотя вблизи полюсов имеются искажения, площадь небольших участков отражает истинную площадь.
Другими псевдоцилиндрическими проекциями являются синусоидальная (``projection='sinu'``) и проекция Робинсона (``projection='robin'``).

```python jupyter={"outputs_hidden": false}
fig = plt.figure(figsize=(8, 6), edgecolor='w')
m = Basemap(projection='moll', resolution=None,
            lat_0=0, lon_0=0)
draw_map(m)
```

Дополнительные аргументы Basemap здесь относятся к центральной широте (``lat_0``) и долготе (``lon_0``) для желаемой карты.


### Перспективные проекции

Перспективные проекции строятся с использованием определенного выбора точки перспективы, подобно тому, как если бы вы фотографировали Землю из определенной точки в пространстве (точки, которая для некоторых проекций технически лежит внутри Земли!).
Одним из распространенных примеров является ортографическая проекция (``projection='ortho'``), которая показывает одну сторону земного шара, как ее видит наблюдатель с очень большого расстояния. Таким образом, она может отображать только половину земного шара за раз.
Другие проекции, основанные на перспективе, включают гномоническую проекцию (``projection='gnom'``) и стереографическую проекцию (``projection='stere'``).
Они часто оказываются наиболее полезными для отображения небольших участков карты.

Вот пример ортографической проекции:

```python jupyter={"outputs_hidden": false}
fig = plt.figure(figsize=(8, 8))
m = Basemap(projection='ortho', resolution=None,
            lat_0=50, lon_0=0)
draw_map(m);
```

### Конические проекции

Коническая проекция проецирует карту на один конус, который затем разворачивается.
Это может привести к очень хорошим локальным свойствам, но области, удаленные от фокусной точки конуса, могут оказаться сильно искаженными.
Одним из примеров этого является равноугольная коническая проекция Ламберта (``projection='lcc'``), которую мы ранее видели на карте Северной Америки.
Он проецирует карту на конус, расположенный таким образом, что две стандартные параллели (указанные в базовой карте как ``lat_1`` и ``lat_2``) имеют хорошо представленные расстояния, при этом масштаб уменьшается между ними и увеличивается за их пределами.
Другими полезными коническими проекциями являются равнопромежуточная коническая проекция (``projection='eqdc'``) и равновеликая проекция Альберса (``projection='aea'``).
Конические проекции, как и перспективные проекции, обычно хорошо подходят для представления небольших и средних участков земного шара.

```python jupyter={"outputs_hidden": false}
fig = plt.figure(figsize=(8, 8))
m = Basemap(projection='lcc', resolution=None,
            lon_0=0, lat_0=50, lat_1=45, lat_2=55,
            width=1.6E7, height=1.2E7)
draw_map(m)
```

### Другие прогнозы

Если вы собираетесь активно использовать визуализацию на основе карт, я рекомендую вам ознакомиться с другими доступными проекциями, а также с их свойствами, преимуществами и недостатками.
Скорее всего, они доступны в [Basemap package](http://matplotlib.org/basemap/users/mapsetup.html).
Если вы достаточно глубоко углубитесь в эту тему, вы обнаружите невероятную субкультуру фанатов геовизуализации, которые будут готовы горячо отстаивать свою любимую проекцию для любого конкретного приложения!


## Рисование фона карты

Ранее мы рассмотрели методы ``bluemarble()`` и ``shadedrelief()`` для проецирования глобальных изображений на карту, а также методы ``drawparallels()`` и ``drawmeridians()`` для рисования линий постоянной широты и долготы.
Пакет Basemap содержит ряд полезных функций для рисования границ физических объектов, таких как континенты, океаны, озера и реки, а также политических границ, таких как границы стран, штатов и округов США.
Ниже приведены некоторые из доступных функций рисования, которые вы, возможно, захотите изучить, используя справочные функции IPython:

- **Физические границы и водоемы**
- ``drawcoastlines()``: Нарисовать линии континентального побережья
- ``drawlsmask()``: нарисовать маску между сушей и морем для использования при проецировании изображений на одну или другую поверхность.
- ``drawmapboundary()``: нарисовать границу карты, включая цвет заливки для океанов.
- ``drawrivers()``: Рисовать реки на карте
- ``fillcontinents()``: заполнить континенты заданным цветом; при желании заполнить озера другим цветом

- **Политические границы**
- ``drawcountries()``: Нарисовать границы стран
- ``drawstates()``: Нарисовать границы штатов США
- ``drawcounties()``: Нарисовать границы округов США

- **Особенности карты**
- ``drawgreatcircle()``: нарисовать большую окружность между двумя точками
- ``drawparallels()``: рисовать линии постоянной широты
- ``drawmeridians()``: рисовать линии постоянной долготы
- ``drawmapscale()``: нарисовать линейный масштаб на карте

- **Изображения всего земного шара**
- ``bluemarble()``: Проецирование изображения синего мрамора НАСА на карту
- ``shadedrelief()``: проецирование изображения затененного рельефа на карту
- ``etopo()``: Нарисуйте рельефное изображение Этопо на карте
- ``warpimage()``: проецирование предоставленного пользователем изображения на карту

Для объектов на основе границ необходимо задать желаемое разрешение при создании изображения базовой карты.
Аргумент ``resolution`` класса ``Basemap`` задает уровень детализации границ: ``'c'`` (грубый), ``'l'`` (низкий), ``'i'`` (средний), ``'h'`` (высокий), ``'f'`` (полный) или ``None``, если границы использоваться не будут.
Этот выбор важен: например, установка границ высокого разрешения на глобальной карте может быть *очень* медленной.

Ниже приведен пример рисования границ суши и моря и влияние параметра разрешения.
Мы создадим карту прекрасного шотландского острова Скай как в низком, так и в высоком разрешении.
Он расположен на 57,3° с.ш., 6,2° з.д., и карта размером 90 000 × 120 000 километров его хорошо показывает:

```python jupyter={"outputs_hidden": false}
fig, ax = plt.subplots(1, 2, figsize=(12, 8))

for i, res in enumerate(['l', 'h']):
    m = Basemap(projection='gnom', lat_0=57.3, lon_0=-6.2,
                width=90000, height=120000, resolution=res, ax=ax[i])
    m.fillcontinents(color="# FFDDCC", lake_color='#DDEEFF')
    m.drawmapboundary(fill_color="# ДДЕЕФФ")
    m.drawcoastlines()
    ax[i].set_title("resolution='{0}'".format(res));
```

Обратите внимание, что береговые линии с низким разрешением не подходят для такого уровня масштабирования, тогда как высокое разрешение работает отлично.
Однако низкий уровень отлично подойдет для глобального представления и будет *гораздо* быстрее, чем загрузка данных о границах высокого разрешения для всего земного шара!
Чтобы найти правильный параметр разрешения для конкретного вида, может потребоваться некоторое экспериментирование: лучший способ — начать с быстрого графика с низким разрешением и увеличивать разрешение по мере необходимости.


## Нанесение данных на карты

Пожалуй, самой полезной частью инструментария Basemap является возможность наложения различных данных на фон карты.
Для простого построения графиков и текста на карте работает любая функция ``plt``; можно использовать экземпляр ``Basemap`` для проецирования координат широты и долготы на координаты ``(x, y)`` для построения графиков с помощью ``plt``, как мы видели ранее в примере Сиэтла.

В дополнение к этому, существует множество функций, специфичных для карт, доступных как методы экземпляра ``Basemap``.
Они работают очень похоже на свои стандартные аналоги Matplotlib, но имеют дополнительный логический аргумент ``latlon``, который, если установлен в ``True``, позволяет передавать в метод сырые значения широты и долготы, а не проецируемые координаты ``(x, y)``.

Вот некоторые из этих методов, специфичных для карт:

- ``contour()``/``contourf()`` : Рисование контурных линий или заполненных контуров
- ``imshow()``: нарисовать изображение
- ``pcolor()``/``pcolormesh()`` : Рисование псевдоцветного графика для нерегулярных/регулярных сеток
- ``plot()``: Рисование линий и/или маркеров.
- ``scatter()``: рисовать точки с помощью маркеров.
- ``quiver()``: Рисование векторов.
- ``barbs()``: Рисовать ветровые зазубрины.
- ``drawgreatcircle()``: Нарисовать большой круг.

По ходу статьи мы рассмотрим несколько примеров некоторых из них.
Дополнительную информацию об этих функциях, включая несколько примеров графиков, см. в [online Basemap documentation](http://matplotlib.org/basemap/).


## Пример: города Калифорнии

Напомним, что в [Customizing Plot Legends](04.06-Customizing-Legends.ipynb) мы продемонстрировали использование размера и цвета в диаграмме рассеяния для передачи информации о местоположении, размере и численности населения городов Калифорнии.
Здесь мы снова создадим этот график, но с использованием Basemap, чтобы поместить данные в контекст.

Начнем с загрузки данных, как мы это делали ранее:

```python jupyter={"outputs_hidden": true}
import pandas as pd
cities = pd.read_csv('data/california_cities.csv')

# Извлечь интересующие нас данные
lat = cities['latd'].values
lon = cities['longd'].values
population = cities['population_total'].values
area = cities['area_total_km2'].values
```

Далее мы настраиваем проекцию карты, распределяем данные, а затем создаем цветовую шкалу и легенду:

```python jupyter={"outputs_hidden": false}
# 1. Нарисуйте фон карты.
fig = plt.figure(figsize=(8, 8))
m = Basemap(projection='lcc', resolution='h', 
            lat_0=37.5, lon_0=-119,
            width=1E6, height=1.2E6)
m.shadedrelief()
m.drawcoastlines(color='gray')
m.drawcountries(color='gray')
m.drawstates(color='gray')

# 2. данные о городах рассеяния, где цвет отражает численность населения
# и размер отражающей области
m.scatter(lon, lat, latlon=True,
          c=np.log10(population), s=area,
          cmap='Reds', alpha=0.5)

# 3. создать цветовую шкалу и легенду
plt.colorbar(label=r'$\log_{10}({\rm population})$')
plt.clim(3, 7)

# создайте легенду с фиктивными точками
for a in [100, 300, 500]:
    plt.scatter([], [], c='k', alpha=0.5, s=a,
                label=str(a) + ' km$^2$')
plt.legend(scatterpoints=1, frameon=False,
           labelspacing=1, loc='lower left');
```

Это примерно показывает нам, где в Калифорнии поселились более крупные популяции людей: они сконцентрированы вблизи побережья в районах Лос-Анджелеса и Сан-Франциско, растянуты вдоль автомагистралей в плоской центральной долине и почти полностью избегают горных районов вдоль границ штата.


## Пример: данные о температуре поверхности

В качестве примера визуализации некоторых более непрерывных географических данных давайте рассмотрим «полярный вихрь», обрушившийся на восточную часть Соединенных Штатов в январе 2014 года.
Отличным источником любых климатических данных является [NASA's Goddard Institute for Space Studies](http://data.giss.nasa.gov/).
Здесь мы будем использовать данные о температуре GIS 250, которые можно загрузить с помощью команд оболочки (эти команды, возможно, придется изменить на компьютерах с Windows).
Использованные здесь данные были загружены 12.06.2016, размер файла составляет приблизительно 9 МБ:

```python jupyter={"outputs_hidden": false}
# !curl -O http://data.giss.nasa.gov/pub/gistemp/gistemp250.nc.gz
# !gunzip gistemp250.nc.gz
```

Данные поступают в формате NetCDF, который можно прочитать в Python с помощью библиотеки ``netCDF4``.
Вы можете установить эту библиотеку, как показано здесь.

```
$ conda install netcdf4
```

Мы интерпретируем данные следующим образом:

```python jupyter={"outputs_hidden": false}
from netCDF4 import Dataset
data = Dataset('gistemp250.nc')
```

Файл содержит множество показаний глобальной температуры на разные даты; нам нужно выбрать индекс интересующей нас даты — в данном случае 15 января 2014 года:

```python jupyter={"outputs_hidden": false}
from netCDF4 import date2index
from datetime import datetime
timeindex = date2index(datetime(2014, 1, 15),
                       data.variables['time'])
```

Теперь мы можем загрузить данные широты и долготы, а также температурную аномалию для этого индекса:

```python jupyter={"outputs_hidden": true}
lat = data.variables['lat'][:]
lon = data.variables['lon'][:]
lon, lat = np.meshgrid(lon, lat)
temp_anomaly = data.variables['tempanomaly'][timeindex]
```

Наконец, мы воспользуемся методом ``pcolormesh()`` для рисования цветовой сетки данных.
Мы рассмотрим Северную Америку и воспользуемся картой рельефа с затенением в качестве фона.
Обратите внимание, что для этих данных мы специально выбрали расходящуюся цветовую карту, которая имеет нейтральный цвет при нуле и два контрастных цвета при отрицательных и положительных значениях.
Мы также слегка нарисуем береговые линии поверх цветов для справки:

```python jupyter={"outputs_hidden": false}
fig = plt.figure(figsize=(10, 8))
m = Basemap(projection='lcc', resolution='c',
            width=8E6, height=8E6, 
            lat_0=45, lon_0=-100,)
m.shadedrelief(scale=0.5)
m.pcolormesh(lon, lat, temp_anomaly,
             latlon=True, cmap='RdBu_r')
plt.clim(-8, 8)
m.drawcoastlines(color='lightgray')

plt.title('January 2014 Temperature Anomaly')
plt.colorbar(label='temperature anomaly (°C)');
```

Полученные данные рисуют картину локальных экстремальных температурных аномалий, наблюдавшихся в течение этого месяца.
В восточной части США было намного холоднее обычного, тогда как в западной части и на Аляске — намного теплее.
Регионы, где не зафиксирована температура, показаны на фоне карты.
