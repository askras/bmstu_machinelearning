---
jupyter:
  jupytext:
    encoding: '# -*- coding: utf-8 -*-'
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Настройка делений на осях координат


Метки делений по умолчанию Matplotlib разработаны так, чтобы быть в целом достаточными во многих распространенных ситуациях, но никоим образом не являются оптимальными для каждого графика. 

Сначала немного подробнее поговорим об иерархии объектов графиков Matplotlib.
Matplotlib стремится создать объект Python, представляющий все, что появляется на графике: например, напомним, что `Figure` — это ограничивающая рамка, внутри которой появляются элементы графика.
Каждый объект Matplotlib также может выступать в качестве контейнера подобъектов: например, каждый `Figure` может содержать один или несколько объектов `Axes`, каждый из которых, в свою очередь, содержит другие объекты, представляющие содержимое графика.

Метки делений не являются исключением. 
Каждая ось имеет атрибуты `xaxis` и `yaxis`, которые в свою очередь имеют атрибуты, содержащие все свойства линий, делений и меток оси координат.

```python
import matplotlib.pyplot as plt
import numpy as np

%matplotlib inline
plt.style.use('default')
```

## Основные и промежуточные метки делений осей координат

На каждой оси координат могут отображаться *основные* и *промежуточные*  деления. 
Как следует из названий, основные деления обычно больше или более выражены, а промежуточные &mdash; обычно меньше. 
По умолчанию Matplotlib редко использует промежуточные деления, но одно из мест, где они встречаются по умолчанию &mdash; это графики с логарифмическим масштабом по осям координат:

```python jupyter={"outputs_hidden": false}
ax = plt.axes(xscale='log', yscale='log')
ax.set(xlim=(1, 1E3), ylim=(1, 1E3))
ax.grid(True);
```

На этой диаграмме каждое основное деление отображается в виде большой отметки, подписи и линии сетки, а каждое второстепенное деление отображается в виде меньшей отметки без подписи или линии сетки.

Можно задать пользовательские настройки для свойств делений (расположений и меток), задав значения объектов `formatter` и `locator` каждой из осей.
Рассмотрим их значения для оси X на графике 

```python jupyter={"outputs_hidden": false} editable=true slideshow={"slide_type": ""}
print(ax.xaxis.get_major_locator())
print(ax.xaxis.get_minor_locator())
```

```python jupyter={"outputs_hidden": false} editable=true slideshow={"slide_type": ""}
print(ax.xaxis.get_major_formatter())
print(ax.xaxis.get_minor_formatter())
```

Как видно, расположение меток как основных, так и промежуточных делений задает локатор `LogLocator` (что логично для логарифмического графика). 
Метки промежуточных делений форматируются форматером `NullFormatter` (это означает, что метки отображаться не будут).

Теперь рассмотрим несколько примеров настройки этих параметров для различных графиков.


## Скрытие делений и/или меток

Пожалуй, наиболее распространенной операцией форматирования деления/меток является их скрытие, с помощью `plt.NullLocator` и `plt.NullFormatter`:

```python jupyter={"outputs_hidden": false}
ax = plt.axes()
rng = np.random.default_rng(1701)
ax.plot(rng.random(50))
ax.grid()

ax.yaxis.set_major_locator(plt.NullLocator())
ax.xaxis.set_major_formatter(plt.NullFormatter())
```

Обратите внимание, что были убраны метки (но остались деления/линии координатной сетки) по оси X, и убраны деления (а следовательно, и метки) по оси Y. 
Полное отсутствие галочек может быть полезно во многих ситуациях, например, когда вы хотите отобразить сетку изображений.
Например, рассмотрим следующий рисунок, включающий изображения разных лиц.
Данный набор изображений часто используется в задачах машинного обучения с учителем.

```python jupyter={"outputs_hidden": false}
fig, ax = plt.subplots(5, 5, figsize=(5, 5))
fig.subplots_adjust(hspace=0, wspace=0)

# Получаем данные о лицах из Scikit-Learn
from sklearn.datasets import fetch_olivetti_faces
faces = fetch_olivetti_faces().images

for i in range(5):
    for j in range(5):
        ax[i, j].xaxis.set_major_locator(plt.NullLocator())
        ax[i, j].yaxis.set_major_locator(plt.NullLocator())
        ax[i, j].imshow(faces[10 * i + j], cmap='binary_r')
```

Каждое изображение отображается в своих собственных осях координат, а локаторы делений установлены в нуль, поскольку значения делений (в данном случае номера пикселей) не несут никакой информации для этой конкретной визуализации.


## Уменьшение или увеличение количества делений

Одной из распространенных проблем с настройками по умолчанию является то, что небольшие подграфики могут оказаться переполненными метками, расположенными слишком близко друг к другу.
Увидеть это можно на сетке графика, показанной здесь:

```python jupyter={"outputs_hidden": false}
fig, ax = plt.subplots(4, 4, sharex=True, sharey=True)
```

В частности, на оси X цифры практически перекрываются, что затрудняет их восприятие.
Один из способов решения данной проблемы &mdash; использование `plt.MaxNLocator`, который позволяет указать максимальное количество отображаемых делений.
Учитывая это максимальное число, Matplotlib будет использовать внутреннюю логику для выбора конкретных местоположений отметок:

```python jupyter={"outputs_hidden": false}
# Для каждой оси устанавливается главный локатор x и y.
for axi in ax.flat:
    axi.xaxis.set_major_locator(plt.MaxNLocator(3))
    axi.yaxis.set_major_locator(plt.MaxNLocator(3))
fig
```

Это делает графики намного более читаемыми. 
Если нужно еще больше контроля над расположением регулярно расположенных отметок, можно использовать `plt.MultipleLocator`.


## Необычные форматы делений

Форматирование делений по умолчанию в Matplotlib хорошо работает во многих случаях, но иногда требуется сделать что-то другое.
Рассмотрим этот график синусоидальной и косинусоидальной кривых:

```python jupyter={"outputs_hidden": false}
# Построение синусоидальной и косинусоидальной кривых
fig, ax = plt.subplots()
x = np.linspace(0, 3 * np.pi, 1000)
ax.plot(x, np.sin(x), lw=3, label=r'$\sin(x)$')
ax.plot(x, np.cos(x), lw=3, label=r'$\cos(x)$')

# Настройка сетки, легенды и ограничений
ax.grid(True)
ax.legend(frameon=False)
ax.axis('equal')
ax.set_xlim(0, 3 * np.pi);
```

Внесем пару изменений.
Во-первых, для этих тригонометрических функций более естественно размещать метки и линии сетки в точках кратных $\pi$. 
Сделать это можно установив `MultipleLocator`, который размещает отметки в точках кратных тем числамх, которые были указаны.
Для верности добавим как основные, так и второстепенные деления в точках кратных $\pi/2$ и $\pi/4$:

```python jupyter={"outputs_hidden": false}
ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 2))
ax.xaxis.set_minor_locator(plt.MultipleLocator(np.pi / 4))
fig
```

Но теперь считывать эти метки неудобно: они действительно кратны $\pi$, но десятичное представление не передает этого сразу.
Для того, чтобы исправить это, нет встроенного форматировщика, поэтому будем использовать `plt.FuncFormatter`, который принимает определяемую пользователем функцию, предоставляя детальный контроль над выходными данными меток делений:

```python jupyter={"outputs_hidden": false}
def format_func(value, tick_number):
    # найти числа кратные pi/2
    N = int(np.round(2 * value / np.pi))
    if N == 0:
        return "0"
    elif N == 1:
        return r"$\pi/2$"
    elif N == 2:
        return r"$\pi$"
    elif N % 2 > 0:
        return rf"${N}\pi/2$"
    else:
        return rf"${N // 2}\pi$"

ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
fig
```

Это намного лучше! 
Обратите внимание, что Matplotlib испоьзует форматирование LaTeX, путем заключения строки в знаки доллара. 
Это очень удобно для отображения математических символов и формул: в этом случае `"$\pi$"` отображается как греческий символ $\pi$.


## Сводка по форматерам и локаторам

Все форматеры и локаторы доступны в пространстве имен `plt`:

Класс локатора     | Описание
-------------------|-------------
`NullLocator`      | Нет делений
`FixedLocator`     | Расположение делений фиксировано
`IndexLocator`     | Локатор для графиков индексированной переменной (например, где `x = range(len(y)))`
`LinearLocator`    | Равномерно распределенные деления от минимума до максимума
`LogLocator`       | Логарифмически распределенные деления от минимума до максимума
`MultipleLocator`  | Деления и диапазон значений кратны заданному основанию
`MaxNLocator`      | Находит удачные местоположения для делений в количестве, не превышающем заданного максимального числа
`AutoLocator`      | (По умолчанию) `MaxNLocator` с простейшими значениями по умолчанию
`AutoMinorLocator` | Локатор для промежуточных делений

Класс форматирования | Описание
--------------------|---------------
`NullFormatter`     | Деления без меток
`IndexFormatter`    | Задает строковые значения для меток на основе списка меток
`FixedFormatter`    | Позволяет задавать строковые значения для меток вручную
`FuncFormatter`     | Значения меток задаются с помощью пользовательской функции
`FormatStrFormatter`| Для всех значений используется строка формата
`ScalarFormatter`   | (По умолчанию.) Форматер для скалярных значений
`LogFormatter`      | Форматер по умолчанию для логарифмических систем координат

Для получения дополнительной информации о любом из локаторов и форматеров следует обратиться к документации Matplotlib.
