---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Построение трехмерных графиков в Matplotlib


Matplotlib изначально разрабатывался исключительно для построения двумерных графиков.
В период выпуска версии 1.0 на основе имевшегося в  Matplotlib были добавлены некоторые утилиты для построения трехмерных графиков. В результате этого появился удобный (хотя и несколько ограниченный) набор инструментов для трехмерной визуализации данных.
Возможность построения трехмерных графиков включается путем импорта набора инструментов `mplot3d`, входящего в основной пакет Matplotlib:

```python jupyter={"outputs_hidden": false}
from mpl_toolkits import mplot3d
```

После импорта этого подмодуля появляется возможность создавать трехмерные оси, передав ключевое слово `projection='3d'` в любую из обычных функций создания осей:

```python
import matplotlib.pyplot as plt
import numpy as np

%matplotlib widget
plt.style.use('default')
```

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')
```

Благодаря включению трехмерных осей координат можно строить различные типы трехмерных графиков.
Трехмерное построение графиков &mdash; один из случаев, для которых очень полезен интерактивный, а не статический режим просмотра рисунков в блокноте. Напомню, что для работы с интерактивными ри-
Именно поэтому, вместо команды `%matplotlib inline` лучше использовать команду `%matplotlib widget`.


## Трехмерные точки и линии

Линейный график или диаграмма рассеяния &mdash; это самые простые варианты трехмерных графиков создаваемых из наборов троек (x, y, z).
По аналогии с двумерными графиками, их можно создать с помощью функций `ax.plot3D` и `ax.scatter3D`.
Сигнатура вызова для них почти идентична сигнатуре их двумерных аналогов.
Рассмотри тригонометрическую спираль вместе с несколькими точками, расположенными случайным образом вблизи линии:

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')

# Данные для трехмерной линии
zline = np.linspace(0, 15, 1000)
xline = np.sin(zline)
yline = np.cos(zline)
ax.plot3D(xline, yline, zline, 'gray')

# Данные для трехмерных точек
zdata = 15 * np.random.random(100)
xdata = np.sin(zdata) + 0.1 * np.random.randn(100)
ydata = np.cos(zdata) + 0.1 * np.random.randn(100)
ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap='Greens');
```

Обратите внимание, что по умолчанию прозрачность точек рассеивания настроена так, чтобы создать ощущение глубины на странице.
Хотя трехмерный эффект иногда трудно увидеть на статическом изображении, интерактивный просмотр может дать хорошее интуитивное представление о расположении точек.


## Трехмерные контурные графики

Аналогично контурным графикам, которые были рассмотрены в мы исследовали в [Графики плотности и контурные графики](matplotlib_04_density_and_contour_plots.md), `mplot3d` содержит инструменты для создания трехмерных рельефных графиков с использованием тех же входных данных.
Как и двумерные графики `ax.contour`, `ax.contour3D` требует, чтобы все входные данные были в виде двумерных регулярных сеток, при этом данные Z вычисляются для каждой точки.
Построим трехмерную контурную диаграмму трехмерной синусоидальной функции:

```python jupyter={"outputs_hidden": false}
def f(x, y):
    return np.sin(np.sqrt(x ** 2 + y ** 2))

x = np.linspace(-6, 6, 30)
y = np.linspace(-6, 6, 30)

X, Y = np.meshgrid(x, y)
Z = f(X, Y)
```

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.contour3D(X, Y, Z, 50, cmap='binary')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z');
```

Если угол обзора предлагаемый по умолчанию не является оптимальным, можно использовать метод `view_init` для установки угла возвышения и азимута. 
В следующем примере используем угол возвышения 60 градусов (то есть 60 градусов над плоскостью x-y) и азимут 35 градусов (то есть повернутый на 35 градусов против часовой стрелки вокруг оси z):

```python jupyter={"outputs_hidden": false}
ax.view_init(60, 35)
fig
```

Еще раз обратите внимание, что этот тип поворота можно выполнить интерактивно, щелкнув и перетащив график в окне просмотра Matplotlib.


## Каркасы и поверхностные графики

Два других типа трехмерных графиков, которые работают с данными в сетке &mdash; это каркасные графики (каркасы) и поверхностные графики.
Они создают проекцию координатных значений на указанную трехмерную поверхность, что позволяет довольно легко визуализировать полученные трехмерные фигуры.
Вот пример использования каркаса:

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_wireframe(X, Y, Z, color='black')
ax.set_title('wireframe');
```

Поверхностный график похож на каркасный график, но каждая грань каркаса представляет собой заполненный многоугольник.
Добавление цветовой карты к заполненным полигонам может помочь восприятию топологии визуализируемой поверхности:

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                cmap='viridis', edgecolor='none')
ax.set_title('surface');
```

Обратите внимание, что хотя сетка значений для поверхностного графика должна быть двумерной, она не обязательно должна быть прямолинейной.
Вот пример созданиянеполной сетки в полярной системе координат, которая при использовании с графиком `surface3D` может дать срез визуализируемой функции:

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')

r = np.linspace(0, 6, 20)
theta = np.linspace(-0.9 * np.pi, 0.8 * np.pi, 40)
r, theta = np.meshgrid(r, theta)

X = r * np.sin(theta)
Y = r * np.cos(theta)
Z = f(X, Y)

ax = plt.axes(projection='3d')
ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                cmap='viridis', edgecolor='none');
```

## Триангуляция поверхностей

В некоторых приложениях необходимые для предыдущих операций равномерно дискретизированные координатные сетки неудобны и накладывают слишком много ограничений. 
В таких ситуациях весьма полезными оказываются графики, построенные на основе триангуляции. 
Пусть вместо равномерного распределения по декартовой или полярной сетке имеется набор случайно выбранных значений:

```python jupyter={"outputs_hidden": false}
theta = 2 * np.pi * np.random.random(1000)
r = 6 * np.random.random(1000)
x = np.ravel(r * np.sin(theta))
y = np.ravel(r * np.cos(theta))
z = f(x, y)
```

Можно было бы создать диаграмму рассеяния точек, чтобы получить представление о поверхности, с которой предстоит работать:

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.scatter(x, y, z, c=z, cmap='viridis', linewidth=0.5);
```

<!-- #region slideshow={"slide_type": "fragment"} -->
Полученный график оставляет желать лучшего.
Функция, которая поможет в этом случае, &mdash; это `ax.plot_trisurf`, которая создает поверхность, находя набор треугольников, образованных смежными точками (напомним, что x, y и z здесь &mdash; это одномерные массивы):
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_trisurf(x, y, z,
                cmap='viridis', edgecolor='none');
```

Результат, конечно, не такой красивый, как при построении с помощью координатной сетки, но гибкость подхода, основанного на триангуляции позволяет строить действительно интересные трехмерные графики.
Например, с помощью этого метода можно построить трехмерную ленту Мёбиуса.


### Пример: Визуализация ленты Мёбиуса

Лента Мёбиуса похожа на полоску бумаги, склеенную в петлю с полуоборотом.
Топологически это довольно интересно, потому что, несмотря на внешний вид, у него всего одна сторона!
Визуализируем такой объект с помощью трехмерных инструментов Matplotlib.
Лента Мёбиуса &mdash; это двумерная лента, поэтому для ее построения, нужны две координаты. Назовем их $\theta$, которая изменяется от $0$ до $2\pi$, и $w$, которая изменяется от -1 до 1:

```python jupyter={"outputs_hidden": false}
theta = np.linspace(0, 2 * np.pi, 30)
w = np.linspace(-0.25, 0.25, 8)
w, theta = np.meshgrid(w, theta)
```

Теперь, исходя из выбранной, параметризации нужно вычислить координаты *(x, y, z)* самой ленты.

Размышляя об этом, можно понять, что происходит два поворота: один &mdash; это изменение положение петли вокруг ее центра (то что было названо $\theta$), а другой &mdash; это скручивание ленты вокруг ее оси (назовем это $\phi$). 
Для ленты Мёбиуса необходимо сделать так, чтобы лента сделала половину оборота за полную петлю, то есть $\Delta\phi = \Delta\theta/2$.

```python jupyter={"outputs_hidden": false}
phi = 0.5 * theta
```

Теперь используем знания по тригонометрии, чтобы вывести трехмерное вложение.
Определим $r$ &mdash; расстояние каждой точки от центра, и используем это для нахождения внутренних координат $(x, y, z)$:

```python jupyter={"outputs_hidden": false}
# радиус в плоскости x-y
r = 1 + w * np.cos(phi)

x = np.ravel(r * np.cos(theta))
y = np.ravel(r * np.sin(theta))
z = np.ravel(w * np.sin(phi))
```

Наконец, чтобы построить объект, необходимо убедиться, что триангуляция правильная. 
Лучший способ сделать это &mdash; определить триангуляцию *в базовой параметризации*, а затем позволить Matplotlib спроецировать эту триангуляцию в трехмерное пространство ленты Мёбиуса.
Это можно сделать следующим образом:

```python jupyter={"outputs_hidden": false}
# триангулировать в базовой параметризации

fig = plt.figure()
ax = plt.axes(projection='3d')

from matplotlib.tri import Triangulation
tri = Triangulation(np.ravel(w), np.ravel(theta))

ax = plt.axes(projection='3d')
ax.plot_trisurf(x, y, z, triangles=tri.triangles,
                cmap='viridis', linewidths=0.2);

ax.set_xlim(-1, 1); ax.set_ylim(-1, 1); ax.set_zlim(-1, 1);
```

Объединив все эти методы, можно создавать и отображать в Matplotlib самые разные трехмерные объекты и узоры.
