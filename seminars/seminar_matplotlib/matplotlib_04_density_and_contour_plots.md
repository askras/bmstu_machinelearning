---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Графики плотности и контурные графики


Иногда бывает полезно отобразить трехмерные данные на двумерной пловскости с помощью контуров или графиков плотности. 
Для этой задачи могут быть полезны три функции Matplotlib: `plt.contour` для контурных графиков, `plt.contourf` для контурных графиков с заполнением и `plt.imshow` для отрисовки изображений.

Начнем с импорта необходимых пакетов и настройки блокнота для построения графиков:

```python
import matplotlib.pyplot as plt
import numpy as np

%matplotlib inline
plt.style.use('default')
```

## Визуализация трехмерной функции


Начнем с демонстрации контурного графика функции $z = f(x, y)$:

```python jupyter={"outputs_hidden": false}
def f(x, y):
    return np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)
```

Контурный график можно создать с помощью функции `plt.contour`.
Он принимает три аргумента: сетку значений *x*, сетку значений *y* и сетку значений *z*.
Значения *x* и *y* представляют собой положения на графике, а значения *z* будут представлены уровнями контуров.
Пожалуй, наиболее простым способом подготовки таких данных является использование функции `np.meshgrid`, которая строит двумерные сетки из одномерных массивов:

```python jupyter={"outputs_hidden": false}
x = np.linspace(0, 5, 100)
y = np.linspace(0, 5, 100)

X, Y = np.meshgrid(x, y)
Z = f(X, Y)
```

Теперь посмотрим как будет выглядеть контурный график данной функции:

```python jupyter={"outputs_hidden": false}
plt.contour(X, Y, Z, colors='black');
```

Обратите внимание, что по умолчанию при использовании одного цвета отрицательные значения представлены пунктирными линиями, а положительные значения &mdash; сплошными линиями.
Можно явно задать цвета, указав цветовую карту с помощью аргумента `cmap`.


```python jupyter={"outputs_hidden": false}
plt.contour(X, Y, Z, cmap='RdGy');
```

В данном примере была использована цветовая карта `RdGy` (сокращение от *Red-Gray*), которая хорошо подходит для центрированных данных.
Matplotlib предлагает широкий выбор цветовых карт, которые можно легко просмотреть в IPython, выполнив автодополнение клавишей Tab в модуле ``plt.cm``:
```
plt.cm.<TAB>
```

Дял еще большей наглядности установим больше линий для отрисовки, а именно 20 равноотстоящих друг от друга интервалов в диапазоне данных:

```python
plt.contour(X, Y, Z, 20, cmap='RdGy');
```

Теперь график выглядит лучше, но промежутки между линиями могут немного отвлекать.
Это можно исправить, построив заполненный контурный график с помощью функции `plt.contourf()` (обратите внимание на `f` в конце), которая имеет практически такой же синтаксис, что и `plt.contour()`.

Кроме того, добавим команду `plt.colorbar()`, которая автоматически создает дополнительную ось для графика с маркированной информацией о цвете:

```python jupyter={"outputs_hidden": false}
plt.contourf(X, Y, Z, 20, cmap='RdGy')
plt.colorbar();
```

Цветовая шкала наглядно показывает, что черные области &mdash; это &laquo;пики&raquo;, а красные области &mdash; &laquo;низины&raquo;.

Одна из потенциальных проблем с этим графиком заключается в том, что он немного &laquo;пятнистый&raquo;. 
То есть, цветовые переходы дискретны, а не непрерывны, что не всегда удобно.
Эту проблему можно решить, установив очень большое количество контуров, но это приведет к неэффективному построению графика: Matplotlib должен будет отображать новый полигон для каждого шага уровня.
Лучший способ справиться с этой проблемой &mdash; использовать функцию `plt.imshow()`, которая интерпретирует двумерную сетку данных как изображение.

Следующий код демонстрирует это:

```python jupyter={"outputs_hidden": false}
plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower',
           cmap='RdGy', aspect='equal')
plt.colorbar();
```

Однако при исползовании `imshow()` тоже имеется несколько потенциальных: 

- `plt.imshow()` не принимает сетку *x* и *y*, поэтому необходимо вручную указать размеры изображения на графике: `extent [xmin, xmax, ymin, ymax]`.
- `plt.imshow()` по умолчанию следует стандартному определению массива изображений, где начало координат находится в верхнем левом углу, а не в нижнем левом углу, как в большинстве контурных графиков. Это поведение можно изменить в случае отображения данных с привязкой к сетке.
- `plt.imshow()` автоматически настраивает соотношение сторон графика в соответствии с входными данными. Установить одинаковый масштаб по осям координат можно помощью, аргумента `aspect='equal')`. 


Наконец, иногда бывает полезно объединить контурные графики и графики изображений.
Например, здесь создадим частично прозрачное фоновое изображение (прозрачность задается параметром `alpha`) и и нарисуем на самих контурах метки (с помощью функции `plt.clabel()`):

```python jupyter={"outputs_hidden": false}
contours = plt.contour(X, Y, Z, 3, colors='black')
plt.clabel(contours, inline=True, fontsize=8)

plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower',
           cmap='RdGy', alpha=0.5)
plt.colorbar();
```

Сочетание этих трех функций &mdash; `plt.contour`, `plt.contourf` и `plt.imshow` &mdash; дает практически безграничные возможности для отображения такого рода трехмерных данных на двухмерном графике.
Более подробную информацию о доступных в этих функциях параметрах можно найти в их документации.
Также смотрите. [Построение трехмерное графиков в Matplotlib](matplotlib_12_three_dimensional_plotting.md).

```python

```
