---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Настройка цветовых шкал


Легенды графиков обозначают отдельные метки отдельных точек.
Для непрерывных меток,основанных на цвете точек, линий или областей отличным инструментом может стать маркированная цветовая шкала.
В Matplotlib цветовая шкала представляет собой отдельную ось, которая может служить ключом к значению цветов на графике.

Начнем с настройки блокнота для построения графиков и импорта функций, которые мы будем использовать:

```python
import matplotlib.pyplot as plt
import numpy as np

%matplotlib inline
plt.style.use('default')
```

<!-- #region slideshow={"slide_type": "fragment"} -->
Простейшую цветовую шкалу можно создать с помощью функции `plt.colorbar`:
<!-- #endregion -->

```python jupyter={"outputs_hidden": false}
x = np.linspace(0, 10, 1000)
I = np.sin(x) * np.cos(x[:, np.newaxis])

plt.imshow(I)
plt.colorbar();
```

Теперь обсудим несколько идей по настройке этих цветных шкал и их эффективному использованию в различных ситуациях.


## Настройка цветовой карты

Цветовую карту можно указать с помощью аргумента `cmap` функции построения графика:

```python jupyter={"outputs_hidden": false}
plt.imshow(I, cmap='gray');
```

Все доступные цветовые карты находятся в пространстве имен `plt.cm`; использование автодополнения по клавише Tab IPython предоставит полный список встроенных возможностей:
```
plt.cm.<TAB>
```
Выбор карты цветов дело совсем не легкое!


Вопросом выбора цветов в визуализации посвящен раздел [interesting discussion](http://Matplotlib.org/1.4.1/users/colormaps.html) документации Matplotlib.

В целом следует знать о трех различных категориях цветовых карт:

- *Последовательные цветовые карты*: они состоят из одной непрерывной последовательности цветов (например, `binary` или `viridis`).
- *Расходящиеся цветовые карты*: они обычно содержат два различных цвета, которые показывают положительные и отрицательные отклонения от среднего значения (например, ``RdBu`` или ``PuOr``).
- *Качественные цветовые карты*: они смешивают цвета без определенной последовательности (например, `rainbow` или `jet`).

Цветовая карта `jet`, которая использовалась по умолчанию в Matplotlib до версии 2.0, является примером качественной цветовой карты.
Ее выбор в качестве карты по умолчанию был весьма неудачен, поскольку качественные карты часто являются плохим выбором для представления количественных данных.
Одной из проблем является тот факт, что качественные карты обычно не демонстрируют равномерного изменения яркости по мере увеличения масштаба.

Продемонстрировать это можно путем преобразования шкалы цветов `jet` в черно-белое представление:

```python jupyter={"outputs_hidden": false}
from matplotlib.colors import LinearSegmentedColormap

def grayscale_cmap(cmap):
    """Возвращает версию заданной цветовой карты в оттенках серого"""
    cmap = plt.get_cmap(cmap)
    colors = cmap(np.arange(cmap.N))
    
    # преобразовать RGBA в воспринимаемую яркость оттенков серого
    # см. http://alienryderflex.com/hsp.html
    RGB_weight = [0.299, 0.587, 0.114]
    luminance = np.sqrt(np.dot(colors[:, :3] ** 2, RGB_weight))
    colors[:, :3] = luminance[:, np.newaxis]
        
    return LinearSegmentedColormap.from_list(cmap.name + "_gray", colors, cmap.N)
    

def view_colormap(cmap):
    """Создает цветовую карту и ее эквивалент в оттенках серого"""
    cmap = plt.get_cmap(cmap)
    colors = cmap(np.arange(cmap.N))
    
    cmap = grayscale_cmap(cmap)
    grayscale = cmap(np.arange(cmap.N))
    
    fig, ax = plt.subplots(2, figsize=(6, 2),
                           subplot_kw=dict(xticks=[], yticks=[]))
    ax[0].imshow([colors], extent=[0, 10, 0, 1])
    ax[1].imshow([grayscale], extent=[0, 10, 0, 1])
```

```python jupyter={"outputs_hidden": false}
view_colormap('jet')
```

```python
import matplotlib
matplotlib.__version__
plt.get_cmap?
```

Обратите внимание на яркие полосы на изображении в оттенках серого.
Даже в полноцветном режиме эта неравномерная яркость означает, что взгляд будет прикован к определенным частям цветового диапазона, что потенциально приводит к акцентированию внимания на несущественных частях набора данных.
Лучше использовать такие цветовые карты, как, например `viridis`, которая специально создана для равномерного изменения яркости во всем диапазоне.
Таким образом, они не только хорошо согласуются с цветовосприятием, но и будут хорошо передаваться при печати в оттенках серого:

```python jupyter={"outputs_hidden": false}
view_colormap('viridis')
```

Если предпочительнее использовать радужные схемы, то хорошим вариантом для непрерывных данных является цветовая карта `cubehelix`:

```python jupyter={"outputs_hidden": false}
view_colormap('cubehelix')
```

Для других ситуаций, например, для отображения положительных и отрицательных отклонений от некоторого среднего значения, могут быть полезны двухцветные цветовые шкалы, такие как `RdBu` (*Red-Blue*). 
Однако, как можно видеть на следующем рисунке, информация о положительных и отрицательных значенияз будет потеряна при переводе в оттенки серого!

```python jupyter={"outputs_hidden": false}
view_colormap('RdBu')
```

Далее рассмотрим примеры использования некоторых из этих цветовых карт.

В Matplotlib доступно большое количество цветовых карт, полную информацию о которых можно получить в документации.
Для более тщательного подхода к выбору цветов можное воспльзоватся такими инструментами, как Seaborn.


### Цветовые ограничения и расширения

Matplotlib обеспечивает широкий спектр настроек цветовой шкалы.
Сама цветовая шкала &mdash; это просто экземпляр `plt.Axes`, поэтому к ним применимы все изученные ранее приемы форматирования осей и шкал.
Цветовая шкала обладает достаточной гибкостью: например, установив свойство `extend`, можно сузить границы диапазона цветов, обозначив выходящие за пределы значения стрелкой сверху и снизу, .
Это может пригодиться, например, при отображении изображения, на котором присутствует шум:

```python jupyter={"outputs_hidden": false}
# генерация шума в в 1% от пикселей изображения
speckles = (np.random.random(I.shape) < 0.01)
I[speckles] = np.random.normal(0, 3, np.count_nonzero(speckles))

plt.figure(figsize=(10, 3.5))

plt.subplot(1, 2, 1)
plt.imshow(I, cmap='RdBu')
plt.colorbar()

plt.subplot(1, 2, 2)
plt.imshow(I, cmap='RdBu')
plt.colorbar(extend='both')
plt.clim(-1, 1);
```

Обратите внимание, что на левом рисунке зашумленные пикселы влияют на пределы диапазона цветов, по этой причине диапазон шума делает совершенно неразличимым интересующие особенности данных. 
На правом рисунке вручную заданы пределы цвета и добавлены стрелки, чтобы указать значения, которые выше или ниже этих пределов.
Результатом является гораздо более полезная визуализация данных.


### Дискретные цветные шкалы

Цветовые карты по умолчанию являются непрерывными, но иногда требуется представить дискретные значения.
Самый простой способ сделать это &mdash; использовать функцию `plt.get_cmap()`, передав ей имя подходящей цветовой карты вместе с желаемым количеством диапазонов:

```python jupyter={"outputs_hidden": false}
plt.imshow(I, cmap=plt.get_cmap('Blues', 6))
plt.colorbar()
plt.clim(-1, 1);
```

Дискретную версию цветовой карты можно использовать так же, как и любую другую цветовую карту.


## Пример: Рукописные цифры

В качестве примера того, где это может быть полезно, давайте рассмотрим интересную визуализацию данных с рукописными цифрами.
Эти данные включены в Scikit-Learn и состоят из почти 2000 миниатюр размером $8 \times 8$ пикселей, содержащих рукописные цифры.

Начнем с загрузки цифровых данных и визуализации нескольких примеров изображений с помощью `plt.imshow()`:

```python jupyter={"outputs_hidden": false}
# загружаем изображения цифр и визуализируем некоторые из них
from sklearn.datasets import load_digits
digits = load_digits(n_class=10)

fig, ax = plt.subplots(8, 8, figsize=(6, 6))
for i, axi in enumerate(ax.flat):
    axi.imshow(digits.images[i], cmap='binary')
    axi.set(xticks=[], yticks=[])
```

Поскольку каждая цифра определяется оттенком ее 64 пикселей, мы можем рассматривать каждую цифру как точку, лежащую в 64-мерном пространстве: каждое измерение представляет яркость одного пикселя.
Однако визуализация взаимосвязей в таких многомерных пространствах может оказаться чрезвычайно сложной.
Одним из способов решения этой проблемы является использование метода *понижения размерности* (*dimensionality reduction*), например, *обучением на базе многообразий* (*manifold learning*), позволяющего уменьшить размерность данных, сохранив при этом существующие  взаимосвязи.
Снижение размерности является примером машинного обучения без учителя (unsupervised machine learning).
Отложив подробности, взглянем на двумерную проекцию обучения многообразия этих цифровых данных.

```python jupyter={"outputs_hidden": false}
%%capture --no-stdout

# Проецируем цифры в двумерное пространство с помощью функции IsoMap
from sklearn.manifold import Isomap
iso = Isomap(n_components=2)
projection = iso.fit_transform(digits.data)
```

Воспользуемся дискретной цветовой картой для просмотра результатов, установив параметры `ticks` и `clim` для улучшения внешнего вида полученной цветовой шкалы:

```python jupyter={"outputs_hidden": false}
# нанести результаты на график
plt.scatter(projection[:, 0], projection[:, 1], lw=0.1,
            c=digits.target, cmap=plt.get_cmap('cubehelix', 10))
plt.colorbar(ticks=range(10), label='digit value')
plt.clim(-0.5, 9.5)
```

Проекция также дает некоторые интересные сведения о взаимосвязях внутри набора данных: например, диапазоны 5 и 3 в этой проекции почти перекрываются, что указывает на то, что некоторые рукописные пятерки и тройки трудно различить, и, следовательно, выше вероятность, что машинный алгоритм классификации будет их путать. 
Другие значения, такие как 0 и 1, находятся на большем расстоянии друг от друга, и поэтому вероятность их путаницы гораздо ниже.
Это наблюдение согласуется с интуицией, поскольку 5 и 3 выглядят гораздо более похожими, чем 0 и 1.
