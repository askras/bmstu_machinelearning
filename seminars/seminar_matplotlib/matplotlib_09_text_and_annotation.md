---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Текст и аннотация


Создание хорошей визуализации подразумевает направление читателя таким образом, чтобы рисунок рассказывал историю.
В некоторых случаях эту историю можно рассказать полностью визуально, без необходимости добавления текста, но в других случаях необходимы небольшие текстовые подсказки и метки.
Возможно, самыми основными типами аннотаций, являются подписи и заголовки осей, но возможности Matplotlib выходят далеко за эти рамки.
Давайте взглянем на некоторые данные и на то, как можно визуализировать и аннотировать их, чтобы помочь передать интересную информацию. 
Нначнем с импорта необходимых пакетов и настройки блокнота для построения графиков:

```python
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

%matplotlib inline
plt.style.use('default')
```

## Преобразования и положение текста

Иногда необходимо привязать текст к положению на осях или рисунке, независимо от данных. 
В Matplotlib это делается путем изменения *преобразования* (*transform*).

Любая структура отображения графики нуждается в некоторой схеме для преобразования между системами координат.
Например, точка данных $(x, y) = (1, 1)$ должна быть каким-то образом представлена в определенном месте на рисунке, которое, в свою очередь, должно быть представлено в пикселях на экране.
С математической точки зрения такие преобразования координат относительно просты, и Matplotlib имеет хорошо развитый набор инструментов, которые он использует внутри для их выполнения (эти инструменты доступны в подмодуле `matplotlib.transforms`).

Среднестатистическому пользователю редко приходится беспокоиться о деталях этих преобразований, но это полезное знанть, когда требуется разместить текст на рисунке. 
Есть три предопределенных преобразования, которые могут быть полезны в этой ситуации:

- `ax.transData`: Преобразование, связанное с координатами данных;
- `ax.transAxes`: Преобразование, связанное с осями (в единицах измерения осей);
- `fig.transFigure`: преобразование, связанное с рисунком (в единицах измерения размеров фигуры).

Рассмотрим пример рисования текста в разных местах с использованием этих преобразований:

```python jupyter={"outputs_hidden": false}
fig, ax = plt.subplots(facecolor='lightgray')
ax.axis([0, 10, 0, 10])

# transform=ax.transData — значение по умолчанию, но все равно его укажем
ax.text(1, 5, ". Data: (1, 5)", transform=ax.transData)
ax.text(0.5, 0.1, ". Axes: (0.5, 0.1)", transform=ax.transAxes)
ax.text(0.2, 0.2, ". Figure: (0.2, 0.2)", transform=fig.transFigure);
```

Обратите внимание, что по умолчанию текст выравнивается выше и слева от указанных координат: здесь &laquo;.&raquo; в начале каждой строки будет приблизительно обозначать указанное местоположение координат.

Координаты `transData` задают обычные координаты данных, связанные с метками осей x и y.
Координаты `transAxes` указывают местоположение от нижнего левого угла осей (здесь белый квадрат) как долю размера оси.
Координаты `transFigure` аналогичны, но указывают положение от нижнего левого угла фигуры (здесь серый прямоугольник) как долю размера фигуры.

Обратите внимание, что если изменить пределы осей, то будут затронуты только координаты `transData`, а остальные останутся неизменными:

<!-- #region jupyter={"outputs_hidden": false} -->
ax.set_xlim(0, 2)
ax.set_ylim(-6, 6)
fig
<!-- #endregion -->

Наблюдать это поведение можно более наглядно, изменив пределы осей в интерактивном режиме.
В блокноте Jupyter, это можно сделать, изменив `%matplotlib inline` на `%matplotlib widget` и воспользовавшись меню для интерактивного изменения графика.


## Стрелки и аннотации

Наряду с отметками делений и текстом, одним из полезных знаком аннотации является простая стрелка.

Рисовать стрелки в Matplotlib зачастую гораздо сложнее, чем можно было бы ожидать.
Хотя существует функция `plt.arrow()`, создаваемые ею стрелки представляют собой объекты SVG, которые будут зависеть от изменяющегося соотношения сторон графиков, и результат редко будет соответствовать замыслу пользователя.
Вместо этого лучше использовать функцию `plt.annotate()`.
Эта функция создает текст и стрелку, причем стрелки можно указывать очень гибко.

Используем `annotate` с несколькими его опциями:

```python jupyter={"outputs_hidden": false}
%matplotlib inline

fig, ax = plt.subplots()

x = np.linspace(0, 20, 1000)
ax.plot(x, np.cos(x))
ax.axis('equal')

ax.annotate('Локальный максимум', xy=(6.28, 1), xytext=(10, 4),
            arrowprops=dict(facecolor='black', shrink=0.05))

ax.annotate('Локальный максимум', xy=(5 * np.pi, -1), xytext=(2, -6),
            arrowprops=dict(arrowstyle="->",
                            connectionstyle="angle3,angleA=0,angleB=-90"));
```

Стиль стрелки контролируется с помощью словаря `arrowprops`, в котором доступно множество параметров.
Эти параметры достаточно подробно описаны в онлайн-документации Matplotlib, поэтому вместо того, чтобы повторять их здесь.
